package Human_IAS_Team
public
	with Types_Constants;
	renames Types_Constants::all;
	with Unreliable_Sensor_Lib;	

	-------------------------------------
	-- Human
	-------------------------------------
	
	system Human
		features
			InputFromIAS : in data port I2H.impl;
			InputFromSensor1 : in data port Sensor_Data.impl;
			InputFromSensor2 : in data port Sensor_Data.impl;
			InputFromSensor3 : in data port Sensor_Data.impl;
			Output : out data port H2I.impl;
		annex agree {**
			guarantee "Respond to message that Sensor1 is unreliable":
				prev(not InputFromIAS.Sensor1_Reliable, false) <=> ((Output.Sensor1_Unreliable_Response = enum(Response, Agree)) or (Output.Sensor1_Unreliable_Response = enum(Response, Disagree))); 
			
			guarantee "Respond to message that Sensor2 is unreliable":
				prev(not InputFromIAS.Sensor2_Reliable, false) <=> ((Output.Sensor2_Unreliable_Response = enum(Response, Agree)) or (Output.Sensor2_Unreliable_Response = enum(Response, Disagree)));
			
			guarantee "Respond to message that Sensor3 is unreliable":
				prev(not InputFromIAS.Sensor3_Reliable, false) <=> ((Output.Sensor3_Unreliable_Response = enum(Response, Agree)) or (Output.Sensor3_Unreliable_Response = enum(Response, Disagree)));		
				
		**};
	end Human;
	
	-------------------------------------
	-- IAS
	-------------------------------------
	
	system IAS
		features
			InputFromHuman : in data port H2I.impl;
			InputFromSensor1 : in data port Sensor_Data.impl;
			InputFromSensor2 : in data port Sensor_Data.impl;
			InputFromSensor3 : in data port Sensor_Data.impl;
			Output : out data port I2H.impl;

		annex agree {**

			eq previous_active_sensor : int = prev(Output.Active_Sensor, 1);
			
			eq previous_recommended_sensor : int = prev(Output.Recommended_Sensor, 1);

			eq previous_z_position : real = if (previous_active_sensor = 1) then 
												prev(InputFromSensor1.Position.Z, 0.0)
											else if (previous_active_sensor = 2) then
													prev(InputFromSensor2.Position.Z, 0.0)
												 else --(previous_active_sensor = 3)
												 	prev(InputFromSensor3.Position.Z, 0.0);
			
			eq Horizontal_Threshold : real = Unreliable_Sensor_Lib::HAL(previous_z_position);
			
			eq Vertical_Threshold : real = Unreliable_Sensor_Lib::VAL(previous_z_position);
							
			eq Sensor1_Reliable: bool, Sensor2_Reliable: bool, Sensor3_Reliable: bool = Unreliable_Sensor_Lib::Sensor_Status(InputFromSensor1, InputFromSensor2, InputFromSensor3, Horizontal_Threshold, Vertical_Threshold);
			
--			node SensorX_Reliable(X: int) returns (out:bool);
--			let
--				out = 	if X = 1 then 
--							prev(Sensor1_Reliable, true)
--						else if X = 2 then 
--								prev(Sensor2_Reliable, true)
--							 else if X = 3 then
--							 		prev(Sensor3_Reliable, true)
--							 	  else false;				
--			tel;
				
			guarantee "Sensor status to operator":
					(Output.Sensor1_Reliable = Sensor1_Reliable)
				and (Output.Sensor2_Reliable = Sensor2_Reliable)
				and (Output.Sensor3_Reliable = Sensor3_Reliable);			
			
			guarantee "Active sensor in range":
					Output.Active_Sensor >= 1 and Output.Active_Sensor <= 3;
			
			guarantee "Recommended active sensor in range":
					Output.Recommended_Sensor >= 0 and Output.Recommended_Sensor <= 3;
			
			guarantee "Recommended active sensor is a reliable sensor":
						Output.Recommended_Sensor = 1 => Sensor1_Reliable
					and Output.Recommended_Sensor = 2 => Sensor2_Reliable
					and Output.Recommended_Sensor = 3 => Sensor3_Reliable;
			
			--Should we instead pick one of the three on some other criteria?
			guarantee "Recommended sensor is NIL if all sensors are unreliable":
					Output.Recommended_Sensor = NIL <=> not Sensor1_Reliable and not Sensor2_Reliable and not Sensor3_Reliable;
			
			guarantee "Unless the active sensor is becomes unreliable, recommend the current active sensor":
						(		(previous_active_sensor = 1 and Sensor1_Reliable)
							or 	(previous_active_sensor = 2 and Sensor2_Reliable)
							or 	(previous_active_sensor = 3 and Sensor3_Reliable))
						=> Output.Recommended_Sensor = previous_active_sensor;
			
			guarantee "If the pilot agrees that the active sensor is unreliable, make the active sensor the previously recommended sensor, unless the previously recommended sensor was NIL":
				previous_recommended_sensor != NIL =>
					(	((previous_active_sensor = 1 and InputFromHuman.Sensor1_Unreliable_Response = enum(Response, Agree)) => 
						Output.Active_Sensor = previous_recommended_sensor
						)
					and ((previous_active_sensor = 2 and InputFromHuman.Sensor2_Unreliable_Response = enum(Response, Agree)) => 
						Output.Active_Sensor = previous_recommended_sensor
						)
					and ((previous_active_sensor = 3 and InputFromHuman.Sensor3_Unreliable_Response = enum(Response, Agree)) => 
						Output.Active_Sensor = previous_recommended_sensor
						)
					);
			
			guarantee "If the pilot disagrees that the active sensor is unreliable, then don't change the active sensor.":
					(	(previous_active_sensor = 1 and InputFromHuman.Sensor1_Unreliable_Response = enum(Response, Disagree))
					or  (previous_active_sensor = 2 and InputFromHuman.Sensor2_Unreliable_Response = enum(Response, Disagree))
					or 	(previous_active_sensor = 3 and InputFromHuman.Sensor3_Unreliable_Response = enum(Response, Disagree))
					) 
					=>
					Output.Active_Sensor = previous_active_sensor;
			
			--Rather than specify how to compute the position using the good sensors, we simply require that the output position be within the threshold of all the positions measured by the good sensors.
			--Q: Is this the right guarantee, or should it be relaxed a bit? Imagine 3 good xpos sensors. Sensor 1: 2.0, Sensor 2: 5.0, Sensor 3: 8.0. Would 4.0 be a reasonable output? It's more than a 3.0 m threshold from Sensor 3.
			--Q: How does this change now that the pilot can disagree?
--			guarantee "Position to operator is within the threshold from all good sensors":
--					(Sensor1_Reliable => Unreliable_Sensor_Lib::all_xyz_vals_within_threshold_of_each_other(
--						Output.Position, InputFromSensor1.Position, Horizontal_Threshold, Vertical_Threshold
--					))
--				and (Sensor2_Reliable => Unreliable_Sensor_Lib::all_xyz_vals_within_threshold_of_each_other(
--					Output.Position, InputFromSensor2.Position, Horizontal_Threshold, Vertical_Threshold
--				))
--				and (Sensor3_Reliable => Unreliable_Sensor_Lib::all_xyz_vals_within_threshold_of_each_other(
--					Output.Position, InputFromSensor3.Position, Horizontal_Threshold, Vertical_Threshold
--				));
						 								
		**};

	end IAS;
	
	-------------------------------------
	-- Sensors
	-------------------------------------
		
	system Sensor1
		features
			Output : out data port Position.impl;
	end Sensor1;
	
	system Sensor2
		features
			Output : out data port Position.impl;
	end Sensor2;
	
	system Sensor3
		features
			Output : out data port Position.impl;
	end Sensor3;
	
	-------------------------------------
	-- Human-Machine Team
	-------------------------------------
	
	system Top
		annex agree {**
			guarantee "Placeholder gaurantee to get AGREE to run": true;
		**};
	end Top;

	system implementation Top.impl
		subcomponents
			Human: system Human;
			IAS: system IAS;
			Sensor1: system Sensor1;
			Sensor2: system Sensor2;
			Sensor3: system Sensor3;
		connections
			Top_impl_new_connection: feature IAS.Output -> Human.InputFromIAS;
			Top_impl_new_connection2: feature Sensor1.Output -> IAS.InputFromSensor1;
			Top_impl_new_connection3: feature Sensor2.Output -> IAS.InputFromSensor2;
			Top_impl_new_connection4: feature Sensor3.Output -> IAS.InputFromSensor3;
			Top_impl_new_connection5: feature Human.Output -> IAS.InputFromHuman;
			Top_impl_new_connection6: feature Sensor1.Output -> Human.InputFromSensor1;
			Top_impl_new_connection7: feature Sensor2.Output -> Human.InputFromSensor2;
			Top_impl_new_connection8: feature Sensor3.Output -> Human.InputFromSensor3;
		annex agree{**

			--------------------------------------------
			-- OBSERVERS (We want these to be invalid.)
			--------------------------------------------
			lemma "Observer: Operator agrees that Sensor 1 is unreliable":
				not (Human.Output.Sensor1_Unreliable_Response = enum(Response, Agree));
				
			lemma "Observer: IAS flags Sensor 1 unreliable":
				IAS.Output.Sensor1_Reliable;
				
			lemma "Observer: All sensors reliable":
				not (	IAS.Output.Sensor1_Reliable
					and IAS.Output.Sensor2_Reliable
					and IAS.Output.Sensor3_Reliable);
					
			lemma "Observer: All sensors unreliable":
					IAS.Output.Sensor1_Reliable
				or 	IAS.Output.Sensor2_Reliable
				or 	IAS.Output.Sensor3_Reliable;
			
			lemma "Observer: The active sensor changes after the initial timestep":
				true -> (IAS.Output.Active_Sensor = prev(IAS.Output.Active_Sensor,1));
			------------------------------------------------------------------------------
			-- LEMMAS (These should be true based on the guarantees of the subcomponents.)
			------------------------------------------------------------------------------
			
			lemma "Pilot responds to unreliable sensor alerts": 
					(prev(not IAS.Output.Sensor1_Reliable, false) <=> ((Human.Output.Sensor1_Unreliable_Response = enum(Response, Agree)) or (Human.Output.Sensor1_Unreliable_Response = enum(Response, Disagree))))
				and (prev(not IAS.Output.Sensor2_Reliable, false) <=> ((Human.Output.Sensor2_Unreliable_Response = enum(Response, Agree)) or (Human.Output.Sensor2_Unreliable_Response = enum(Response, Disagree))))
				and (prev(not IAS.Output.Sensor3_Reliable, false) <=> ((Human.Output.Sensor3_Unreliable_Response = enum(Response, Agree)) or (Human.Output.Sensor3_Unreliable_Response = enum(Response, Disagree))));
							
			lemma "We can't have just Sensor 1 reliable":
				not (	 IAS.Output.Sensor1_Reliable and not IAS.Output.Sensor2_Reliable and not IAS.Output.Sensor3_Reliable);
			
			lemma "We can't have just Sensor 2 reliable":
				not (not IAS.Output.Sensor1_Reliable and 	 IAS.Output.Sensor2_Reliable and not IAS.Output.Sensor3_Reliable);
							
			lemma "We can't have just Sensor 3 reliable":
				not (not IAS.Output.Sensor1_Reliable and not IAS.Output.Sensor2_Reliable and 	 IAS.Output.Sensor3_Reliable);
			
--			lemma "If the pilot agrees with the IAS assessment, then the active sensor is a reliable sensor (on the previous timestep)":
--			
			
		**};
	end Top.impl;
	
	
end Human_IAS_Team;
