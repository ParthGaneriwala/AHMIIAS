package Human_IAS_Team
public
	with Base_Types;
	
	-------------------------------------
	-- Data Types
	-------------------------------------
	
	data H2I
	end H2I;
	
	data implementation H2I.impl
		subcomponents
			Ack_Sensor1_Unreliable: data Base_Types::Boolean;
			Ack_Sensor2_Unreliable: data Base_Types::Boolean;
			Ack_Sensor3_Unreliable: data Base_Types::Boolean;
	end H2I.impl;
	
	data I2H
	end I2H;
	
	data implementation I2H.impl
		subcomponents
			Sensor1_Reliable: 	data Base_Types::Boolean;
			Sensor2_Reliable: 	data Base_Types::Boolean;
			Sensor3_Reliable: 	data Base_Types::Boolean;
			Position: 			data Position.impl;
	end I2H.impl;
	
	data Position
	end Position;
	
	data implementation Position.impl
		subcomponents
			X: data Base_Types::Float;
			Y: data Base_Types::Float;
			Z: data Base_Types::Float;							
	end Position.impl;

	data Sensor_Data
	end Sensor_Data;
	
	data implementation Sensor_Data.impl
		subcomponents
			Position: data Position.impl;
	end Sensor_Data.impl;

	-------------------------------------
	-- Human
	-------------------------------------
	
	system Human
		features
			InputFromIAS : in data port I2H.impl;
			InputFromSensor1 : in data port Sensor_Data.impl;
			InputFromSensor2 : in data port Sensor_Data.impl;
			InputFromSensor3 : in data port Sensor_Data.impl;
			Output : out data port H2I.impl;
		annex agree {**
			guarantee "Acknowledge receipt of message that Sensor1 is unreliable":
				prev(not InputFromIAS.Sensor1_Reliable, false) <=> Output.Ack_Sensor1_Unreliable;
			
			guarantee "Acknowledge receipt of message that Sensor2 is unreliable":
				prev(not InputFromIAS.Sensor2_Reliable, false) <=> Output.Ack_Sensor2_Unreliable;
				
			guarantee "Acknowledge receipt of message that Sensor3 is unreliable":
				prev(not InputFromIAS.Sensor3_Reliable, false) <=> Output.Ack_Sensor3_Unreliable;
		**};
	end Human;
	
	-------------------------------------
	-- IAS
	-------------------------------------
	
	system IAS
		features
			InputFromHuman : in data port H2I.impl;
			InputFromSensor1 : in data port Sensor_Data.impl;
			InputFromSensor2 : in data port Sensor_Data.impl;
			InputFromSensor3 : in data port Sensor_Data.impl;
			Output : out data port I2H.impl;

		annex agree {**
			node abs(val: real) returns (out: real);
			let
				out = if val >= 0.0 then val else val*-1.0;
			tel;
			
			node vals_within_threshold_of_each_other(val1: real, val2: real, threshold: real) returns (out: bool);
			let
				out = (abs(val1-val2) < threshold); 
			tel;
			
			node all_xyz_vals_within_threshold_of_each_other(pos1: Position.impl, pos2: Position.impl, Horizontal_Threshold : real, Vertical_Threshold : real) returns (out: bool);
			let
				out = (		vals_within_threshold_of_each_other(pos1.X, pos2.X, Horizontal_Threshold)
						and vals_within_threshold_of_each_other(pos1.Y, pos2.Y, Horizontal_Threshold)
						and vals_within_threshold_of_each_other(pos1.Z, pos2.Z, Vertical_Threshold));
			tel;
			
			node Sensor_Status(Sensor1_Data : Sensor_Data.impl, Sensor2_Data : Sensor_Data.impl, Sensor3_Data : Sensor_Data.impl, Horizontal_Threshold : real, Vertical_Threshold : real) returns (Sensor1_Reliable: bool, Sensor2_Reliable: bool, Sensor3_Reliable: bool);
			var 
				Sensor_1_2_Agreement : bool;
				Sensor_1_3_Agreement : bool;
				Sensor_2_3_Agreement : bool;
			let
				Sensor_1_2_Agreement = all_xyz_vals_within_threshold_of_each_other(Sensor1_Data.Position, Sensor2_Data.Position, Horizontal_Threshold, Vertical_Threshold);
				Sensor_1_3_Agreement = all_xyz_vals_within_threshold_of_each_other(Sensor1_Data.Position, Sensor3_Data.Position, Horizontal_Threshold, Vertical_Threshold);
				Sensor_2_3_Agreement = all_xyz_vals_within_threshold_of_each_other(Sensor2_Data.Position, Sensor3_Data.Position, Horizontal_Threshold, Vertical_Threshold);
				
				--A sensor is considered reliable if all XYZ values are within the threhold of one of the other position sensors.
	  			Sensor1_Reliable = Sensor_1_2_Agreement or Sensor_1_3_Agreement;
	  			Sensor2_Reliable = Sensor_1_2_Agreement or Sensor_2_3_Agreement;
	  			Sensor3_Reliable = Sensor_1_3_Agreement or Sensor_2_3_Agreement;
			tel; 
								
			eq previous_z_position : real = prev(Output.Position.Z, 0.0);
			
			const TAKEOFF_LANDING_MIN_AGL : real = 		0.0;
			--Takeoff/Landing AGL Range
			const TAKEOFF_LANDING_MAX_AGL : real = 		50.0;
			--Approach/Departure Low Altitude AGL Range
			const A_D_LOW_ALTITUDE_MAX_AGL : real = 	250.0;
			--Approach/Departure High Altitude AGL Range
			const A_D_HIGH_ALTITUDE_MAX_AGL : real = 	1000.0;
			--En route AGL Range
			const EN_ROUTE_MAX_AGL : real = 			3000.0;  
			
			const TAKEOFF_LANDING_MIN_HAL : real = 		3.0;
			--Takeoff/Landing HAL Range
			const TAKEOFF_LANDING_MAX_HAL : real = 		5.0;
			--Approach/Departure Low Altitude HAL Range
			const A_D_LOW_ALTITUDE_MAX_HAL : real = 	40.0;
			--Approach/Departure High Altitude HAL Range
			const A_D_HIGH_ALTITUDE_MAX_HAL : real = 	80.0;
			--En route HAL Range
			const EN_ROUTE_MAX_HAL : real = 			150.0;  
			
			--Notes:
			--1) When ranges are shown (such as 1-5) for HAL and time to alert, this indicates a limit scaled linearly across the AGL range for that phase with the tightest requirement specified for the minimum AGL and the loosest for the maximum AGL for that phase 
			--2) AGL ranges are notional and may depend on the height and proximity of obstacles in the takeoff and landing area			
			 
			--Compute Horizontal_Threshold using y = mx+b and values in the table
												--Takeoff/Landing
			eq Horizontal_Threshold : real = 	if previous_z_position 		< TAKEOFF_LANDING_MAX_AGL then 
													(TAKEOFF_LANDING_MAX_HAL 	- TAKEOFF_LANDING_MIN_HAL)	/(TAKEOFF_LANDING_MAX_AGL 	- TAKEOFF_LANDING_MIN_AGL)	*previous_z_position + TAKEOFF_LANDING_MIN_HAL
												---Approach/Departure Low Altitude
												else if previous_z_position < A_D_LOW_ALTITUDE_MAX_AGL then 
													(A_D_LOW_ALTITUDE_MAX_HAL 	- TAKEOFF_LANDING_MAX_HAL)	/(A_D_LOW_ALTITUDE_MAX_AGL 	- TAKEOFF_LANDING_MAX_AGL)	*previous_z_position + TAKEOFF_LANDING_MAX_HAL
												--Approach/Departure High Altitude
												else if previous_z_position < A_D_HIGH_ALTITUDE_MAX_AGL then 
													(A_D_HIGH_ALTITUDE_MAX_HAL 	- A_D_LOW_ALTITUDE_MAX_HAL)	/(A_D_HIGH_ALTITUDE_MAX_AGL - A_D_LOW_ALTITUDE_MAX_AGL)	*previous_z_position + A_D_LOW_ALTITUDE_MAX_HAL
												--En route 
												else if previous_z_position < EN_ROUTE_MAX_AGL then 
													(EN_ROUTE_MAX_HAL 			- A_D_HIGH_ALTITUDE_MAX_HAL)/(EN_ROUTE_MAX_AGL 			- A_D_HIGH_ALTITUDE_MAX_AGL)*previous_z_position + A_D_HIGH_ALTITUDE_MAX_HAL
												else
													EN_ROUTE_MAX_HAL;
			
			eq Vertical_Threshold : real = 1.0;
				
			eq Sensor1_Reliable: bool, Sensor2_Reliable: bool, Sensor3_Reliable: bool = Sensor_Status(InputFromSensor1, InputFromSensor2, InputFromSensor3, Horizontal_Threshold, Vertical_Threshold);
				
			guarantee "Sensor sensor status to pilot":
					(Output.Sensor1_Reliable = Sensor1_Reliable)
				and (Output.Sensor2_Reliable = Sensor2_Reliable)
				and (Output.Sensor3_Reliable = Sensor3_Reliable);			
			
			--Rather than specify how to compute the position using the good sensors, we simply require that the output position be within the threshold of all the positions measured by the good sensors.
			--Q: Is this the right guarantee, or should it be relaxed a bit? Imagine 3 good xpos sensors. Sensor 1: 2.0, Sensor 2: 5.0, Sensor 3: 8.0. Would 4.0 be a reasonable output? It's more than a 3.0 m threshold from Sensor 3.
			guarantee "Position to pilot is within the threshold from all good sensors":
					(Sensor1_Reliable => all_xyz_vals_within_threshold_of_each_other(Output.Position, InputFromSensor1.Position, Horizontal_Threshold, Vertical_Threshold))
				and (Sensor2_Reliable => all_xyz_vals_within_threshold_of_each_other(Output.Position, InputFromSensor2.Position, Horizontal_Threshold, Vertical_Threshold))
				and (Sensor3_Reliable => all_xyz_vals_within_threshold_of_each_other(Output.Position, InputFromSensor3.Position, Horizontal_Threshold, Vertical_Threshold));
						 								
		**};

	end IAS;
	
	-------------------------------------
	-- Sensors
	-------------------------------------
		
	system Sensor1
		features
			Output : out data port Position.impl;
	end Sensor1;
	
	system Sensor2
		features
			Output : out data port Position.impl;
	end Sensor2;
	
	system Sensor3
		features
			Output : out data port Position.impl;
	end Sensor3;
	
	-------------------------------------
	-- Human-Machine Team
	-------------------------------------
	
	system Top
		annex agree {**
			guarantee "Placeholder gaurantee to get AGREE to run": true;
		**};
	end Top;

	system implementation Top.impl
		subcomponents
			Human: system Human;
			IAS: system IAS;
			Sensor1: system Sensor1;
			Sensor2: system Sensor2;
			Sensor3: system Sensor3;
		connections
			Top_impl_new_connection: feature IAS.Output -> Human.InputFromIAS;
			Top_impl_new_connection2: feature Sensor1.Output -> IAS.InputFromSensor1;
			Top_impl_new_connection3: feature Sensor2.Output -> IAS.InputFromSensor2;
			Top_impl_new_connection4: feature Sensor3.Output -> IAS.InputFromSensor3;
			Top_impl_new_connection5: feature Human.Output -> IAS.InputFromHuman;
			Top_impl_new_connection6: feature Sensor1.Output -> Human.InputFromSensor1;
			Top_impl_new_connection7: feature Sensor2.Output -> Human.InputFromSensor2;
			Top_impl_new_connection8: feature Sensor3.Output -> Human.InputFromSensor3;
		annex agree{**

			--------------------------------------------
			-- OBSERVERS (We want these to be invalid.)
			--------------------------------------------
			lemma "Observer: Pilot acknowledges Sensor 1 unreliable":
				not Human.Output.Ack_Sensor1_Unreliable;
				
			lemma "Observer: IAS flags Sensor 1 unreliable":
				IAS.Output.Sensor1_Reliable;
				
			lemma "Observer: All sensors reliable":
				not (	IAS.Output.Sensor1_Reliable
					and IAS.Output.Sensor2_Reliable
					and IAS.Output.Sensor3_Reliable);
					
			lemma "Observer: All sensors unreliable":
					IAS.Output.Sensor1_Reliable
				or 	IAS.Output.Sensor2_Reliable
				or 	IAS.Output.Sensor3_Reliable;
			
			------------------------------------------------------------------------------
			-- LEMMAS (These should be true based on the guarantees of the subcomponents.)
			------------------------------------------------------------------------------
				
			lemma "Pilot acknowledges unreliable sensor alerts": 
					(prev(not IAS.Output.Sensor1_Reliable, false) <=> Human.Output.Ack_Sensor1_Unreliable)
				and (prev(not IAS.Output.Sensor2_Reliable, false) <=> Human.Output.Ack_Sensor2_Unreliable)
				and (prev(not IAS.Output.Sensor3_Reliable, false) <=> Human.Output.Ack_Sensor3_Unreliable);
							
		**};
	end Top.impl;
	
	
end Human_IAS_Team;
