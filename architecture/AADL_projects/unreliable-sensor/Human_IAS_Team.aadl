package Human_IAS_Team
public
	with Base_Types;
	
	-------------------------------------
	-- Data Types
	-------------------------------------
	
	data H2I
	end H2I;
	
	data implementation H2I.impl
		subcomponents
			Ack_Sensor1_Unreliable: data Base_Types::Boolean;
			Ack_Sensor2_Unreliable: data Base_Types::Boolean;
			Ack_Sensor3_Unreliable: data Base_Types::Boolean;
	end H2I.impl;
	
	data I2H
	end I2H;
	
	data implementation I2H.impl
		subcomponents
			Sensor1_Reliable: 	data Base_Types::Boolean;
			Sensor2_Reliable: 	data Base_Types::Boolean;
			Sensor3_Reliable: 	data Base_Types::Boolean;
			Position: 			data Position.impl;
	end I2H.impl;
	
	data Position
	end Position;
	
	data implementation Position.impl
		subcomponents
			X: data Base_Types::Float;
			Y: data Base_Types::Float;
			Z: data Base_Types::Float;							
	end Position.impl;

	data Sensor_Data
	end Sensor_Data;
	
	data implementation Sensor_Data.impl
		subcomponents
			Position: data Position.impl;
	end Sensor_Data.impl;

	-------------------------------------
	-- Human
	-------------------------------------
	
	system Human
		features
			InputFromIAS : in data port I2H.impl;
			InputFromSensor1 : in data port Sensor_Data.impl;
			InputFromSensor2 : in data port Sensor_Data.impl;
			InputFromSensor3 : in data port Sensor_Data.impl;
			Output : out data port H2I.impl;
		annex agree {**
			guarantee "Acknowledge receipt of message that Sensor1 is unreliable":
				prev(not InputFromIAS.Sensor1_Reliable, false) <=> Output.Ack_Sensor1_Unreliable;
			
			guarantee "Acknowledge receipt of message that Sensor2 is unreliable":
				prev(not InputFromIAS.Sensor2_Reliable, false) <=> Output.Ack_Sensor2_Unreliable;
				
			guarantee "Acknowledge receipt of message that Sensor3 is unreliable":
				prev(not InputFromIAS.Sensor3_Reliable, false) <=> Output.Ack_Sensor3_Unreliable;
		**};
	end Human;
	
	-------------------------------------
	-- IAS
	-------------------------------------
	
	system IAS
		features
			InputFromHuman : in data port H2I.impl;
			InputFromSensor1 : in data port Sensor_Data.impl;
			InputFromSensor2 : in data port Sensor_Data.impl;
			InputFromSensor3 : in data port Sensor_Data.impl;
			Output : out data port I2H.impl;

		annex agree {**
			node abs(val: real) returns (out: real);
			let
				out = if val >= 0.0 then val else val*-1.0;
			tel;
			
			node vals_within_threshold_of_each_other(val1: real, val2: real, threshold: real) returns (out: bool);
			let
				out = (abs(val1-val2) < threshold); 
			tel;
			
			node all_xyz_vals_within_threshold_of_each_other(pos1: Position.impl, pos2: Position.impl, Horizontal_Threshold : real, Vertical_Threshold : real) returns (out: bool);
			let
				out = (		vals_within_threshold_of_each_other(pos1.X, pos2.X, Horizontal_Threshold)
						and vals_within_threshold_of_each_other(pos1.Y, pos2.Y, Horizontal_Threshold)
						and vals_within_threshold_of_each_other(pos1.Z, pos2.Z, Vertical_Threshold));
			tel;
			
			node Sensor_Status(Sensor1_Data : Sensor_Data.impl, Sensor2_Data : Sensor_Data.impl, Sensor3_Data : Sensor_Data.impl, Horizontal_Threshold : real, Vertical_Threshold : real) returns (Sensor1_Reliable: bool, Sensor2_Reliable: bool, Sensor3_Reliable: bool);
			var 
				Sensor_1_2_Agreement : bool;
				Sensor_1_3_Agreement : bool;
				Sensor_2_3_Agreement : bool;
			let
				Sensor_1_2_Agreement = all_xyz_vals_within_threshold_of_each_other(Sensor1_Data.Position, Sensor2_Data.Position, Horizontal_Threshold, Vertical_Threshold);
				Sensor_1_3_Agreement = all_xyz_vals_within_threshold_of_each_other(Sensor1_Data.Position, Sensor3_Data.Position, Horizontal_Threshold, Vertical_Threshold);
				Sensor_2_3_Agreement = all_xyz_vals_within_threshold_of_each_other(Sensor2_Data.Position, Sensor3_Data.Position, Horizontal_Threshold, Vertical_Threshold);
				
				--A sensor is considered reliable if all XYZ values are within the threhold of one of the other position sensors.
	  			Sensor1_Reliable = Sensor_1_2_Agreement or Sensor_1_3_Agreement;
	  			Sensor2_Reliable = Sensor_1_2_Agreement or Sensor_2_3_Agreement;
	  			Sensor3_Reliable = Sensor_1_3_Agreement or Sensor_2_3_Agreement;
			tel; 
			
			eq previous_z_position : real = prev(Output.Position.Z, 0.0);
			
			eq Horizontal_Threshold : real = 	if previous_z_position < 50.0 then 
													2.0/50.0*previous_z_position + 3.0
												else if previous_z_position < 200.0 then
													35.0/150.0*(previous_z_position-50.0) + 5.0
												else if previous_z_position < 1000.0 then
													40.0/800.0*(previous_z_position - 200.0)+ 40.0
												else if previous_z_position < 3000.0 then
													70.0/2000.0*(previous_z_position - 1000.0)+ 80.0
												else
													150.0;
						
			eq Vertical_Threshold : real = 1.0;
				
			eq Sensor1_Reliable: bool, Sensor2_Reliable: bool, Sensor3_Reliable: bool = Sensor_Status(InputFromSensor1, InputFromSensor2, InputFromSensor3, Horizontal_Threshold, Vertical_Threshold);
				
			guarantee "Sensor sensor status to pilot":
					(Output.Sensor1_Reliable = Sensor1_Reliable)
				and (Output.Sensor2_Reliable = Sensor2_Reliable)
				and (Output.Sensor3_Reliable = Sensor3_Reliable);			
			
			--Rather than specify how to compute the position using the good sensors, we simply require that the output position be within the threshold of all the positions measured by the good sensors.
			--Q: Is this the right guarantee, or should it be relaxed a bit? Imagine 3 good xpos sensors. Sensor 1: 2.0, Sensor 2: 5.0, Sensor 3: 8.0. Would 4.0 be a reasonable output? It's more than a 3.0 m threshold from Sensor 3.
			guarantee "Position to pilot is within the threshold from all good sensors":
					(Sensor1_Reliable => all_xyz_vals_within_threshold_of_each_other(Output.Position, InputFromSensor1.Position, Horizontal_Threshold, Vertical_Threshold))
				and (Sensor2_Reliable => all_xyz_vals_within_threshold_of_each_other(Output.Position, InputFromSensor2.Position, Horizontal_Threshold, Vertical_Threshold))
				and (Sensor3_Reliable => all_xyz_vals_within_threshold_of_each_other(Output.Position, InputFromSensor3.Position, Horizontal_Threshold, Vertical_Threshold));
						 								
		**};

	end IAS;
	
	-------------------------------------
	-- Sensors
	-------------------------------------
		
	system Sensor1
		features
			Output : out data port Position.impl;
	end Sensor1;
	
	system Sensor2
		features
			Output : out data port Position.impl;
	end Sensor2;
	
	system Sensor3
		features
			Output : out data port Position.impl;
	end Sensor3;
	
	-------------------------------------
	-- Human-Machine Team
	-------------------------------------
	
	system Top
		annex agree {**
			guarantee "Placeholder gaurantee to get AGREE to run": true;
		**};
	end Top;

	system implementation Top.impl
		subcomponents
			Human: system Human;
			IAS: system IAS;
			Sensor1: system Sensor1;
			Sensor2: system Sensor2;
			Sensor3: system Sensor3;
		connections
			Top_impl_new_connection: feature IAS.Output -> Human.InputFromIAS;
			Top_impl_new_connection2: feature Sensor1.Output -> IAS.InputFromSensor1;
			Top_impl_new_connection3: feature Sensor2.Output -> IAS.InputFromSensor2;
			Top_impl_new_connection4: feature Sensor3.Output -> IAS.InputFromSensor3;
			Top_impl_new_connection5: feature Human.Output -> IAS.InputFromHuman;
			Top_impl_new_connection6: feature Sensor1.Output -> Human.InputFromSensor1;
			Top_impl_new_connection7: feature Sensor2.Output -> Human.InputFromSensor2;
			Top_impl_new_connection8: feature Sensor3.Output -> Human.InputFromSensor3;
		annex agree{**

			--------------------------------------------
			-- OBSERVERS (We want these to be invalid.)
			--------------------------------------------
			lemma "Observer: Pilot acknowledges Sensor 1 unreliable":
				not Human.Output.Ack_Sensor1_Unreliable;
				
			lemma "Observer: IAS flags Sensor 1 unreliable":
				IAS.Output.Sensor1_Reliable;
				
			lemma "Observer: All sensors reliable":
				not (	IAS.Output.Sensor1_Reliable
					and IAS.Output.Sensor2_Reliable
					and IAS.Output.Sensor3_Reliable);
					
			lemma "Observer: All sensors unreliable":
					IAS.Output.Sensor1_Reliable
				or 	IAS.Output.Sensor2_Reliable
				or 	IAS.Output.Sensor3_Reliable;
			
			------------------------------------------------------------------------------
			-- LEMMAS (These should be true based on the guarantees of the subcomponents.)
			------------------------------------------------------------------------------
				
			lemma "Pilot acknowledges unreliable sensor alerts": 
					(prev(not IAS.Output.Sensor1_Reliable, false) <=> Human.Output.Ack_Sensor1_Unreliable)
				and (prev(not IAS.Output.Sensor2_Reliable, false) <=> Human.Output.Ack_Sensor2_Unreliable)
				and (prev(not IAS.Output.Sensor3_Reliable, false) <=> Human.Output.Ack_Sensor3_Unreliable);
							
		**};
	end Top.impl;
	
	
end Human_IAS_Team;
