package Types_Constants
public
	with Base_Types;
	with Data_Model;

	-------------------------------------
	-- Constants
	-------------------------------------
	annex agree {**
		const NIL : int = 0;	
	**};

	-------------------------------------
	-- Data Types
	-------------------------------------
	
	---------------------------------------------------------
	-- S.F.R. 2022/05
	
	-- NOTE: how does the notion of sensor error compare with that of reliability (Unreliable_Sensor_Lib)? 
	--		 A sensor error is the deviation of the measured value from the actual value
	--       A position sensor is classified reliable iff its measured position is sufficiently close to that of at least another sensor
	--		 In principle, all sensors can be classified reliable, while being utterly erroneous (high precision vs low accuracy) 
	
	-- PROPERTIES TO BE VALIDATED (AND POSSIBLY ENFORCED):
	--		 If a sensor error is zero (or below a threshold), then the sensor is classified reliable
	--				NOTE: currently not holding, since the two other sensors positions might be equally distant from the only really reliable sensor
	--		 If two sensors errors are zero (or below a threshold), then the two sensors are classified reliable	
	--				NOTE: more in line with the current reliability pairwise evaluation approach
	
	-- NOTE: error computation, numerical thresholds and determination of error ranges for each sensor are deferred to SW processes (TODO model in AADL)
	data SensorErrorRange
		properties
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("Normal", "Level1", "Level2", "Safety");
	end SensorErrorRange;
		
	-- ASSUMPTION: multiple sensors can be arbitrarily erroneous at the same step
	-- ASSUMPTION: the error can also be negative
	-- QUESTION: can a sensor error arbitrarily fluctuate between Normal and Safety ranges?	
	data SensorErrorData
	end SensorErrorData;
	
	data implementation SensorErrorData.impl
		subcomponents
			error:			data Base_Types::Float;
			errorRange:		data SensorErrorRange;
			errorAlert:		data Base_Types::Boolean;
	end SensorErrorData.impl;

	-- NOTE: component "sensorErrorAlert" necessary due to the choice of having a data port, rather than an event data port, for denoting the  
	--       presence/absence of an alert communication to the operator
	data SensorAlertData
	end SensorAlertData;
	
	data implementation SensorAlertData.impl
		subcomponents
			error:			data Base_Types::Float;
			errorAlert:		data Base_Types::Boolean;
	end SensorAlertData.impl;

	-- NOTE: value "None" necessary due to the choice of having a data port, rather than an event data port, for denoting no response in absence of 
	--       an alert communication to the operator
	data SensorAlertResponse
		properties
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("Accept", "Reject", "None");
	end SensorAlertResponse;
	---------------------------------------------------------

	data Response
		properties
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("Agree", "Disagree", "Neutral");
	end Response;
	
	data Phase_Type
		properties
			Data_Model::Data_Representation => Enum;
			Data_Model::Enumerators => ("On_Ground", "In_Flight", "Landing");
	end Phase_Type;
	
	data H2I
	end H2I;
	
	data implementation H2I.impl
		subcomponents
			Sensor1_Unreliable_Response: 	data Response;
			Sensor2_Unreliable_Response: 	data Response;
			Sensor3_Unreliable_Response: 	data Response;	
			Initiate_Landing:				data Base_Types::Boolean;
			Abort_Landing:					data Base_Types::Boolean;
			Landing_Option_Selection:		data Base_Types::Integer;	
	end H2I.impl;
	
	data I2H
	end I2H;
	
	data implementation I2H.impl
		subcomponents
			Sensor1_Reliable: 			data Base_Types::Boolean;
			Sensor2_Reliable: 			data Base_Types::Boolean;
			Sensor3_Reliable: 			data Base_Types::Boolean;
			Active_Sensor:				data Base_Types::Integer;
			Recommended_Sensor:			data Base_Types::Integer;
			Phase:						data Phase_Type;
			Destination:				data Base_Types::Integer;
			Landing_Options_Ready: 		data Base_Types::Boolean;
			Landing_Options:			data Landing_Options.impl;			
	end I2H.impl;
	
	data Landing_Options		
	end Landing_Options;
	
	data implementation Landing_Options.impl
		subcomponents
			Option1: data Base_Types::Integer;
			Option2: data Base_Types::Integer;
			Option3: data Base_Types::Integer;
	end Landing_Options.impl;
	
	data Position
	end Position;
	
	data implementation Position.impl
		subcomponents
			X: data Base_Types::Float;
			Y: data Base_Types::Float;
			Z: data Base_Types::Float;							
	end Position.impl;

	data Sensor_Data
	end Sensor_Data;
	
	data implementation Sensor_Data.impl
		subcomponents
			Position: data Position.impl;
	end Sensor_Data.impl;
	
end Types_Constants;