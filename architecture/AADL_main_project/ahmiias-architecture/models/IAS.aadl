package IAS
public
	with Types_Constants;
	renames Types_Constants::all;
	with Unreliable_Sensor_Lib;	
	with Base_Types;
	
	-------------------------------------
	-- IAS
	-------------------------------------
	system IAS
		features
			InputFromHuman : 		in data port H2I.impl;
			InputFromSensor1 : 		in data port Sensor_Data.impl;
			InputFromSensor2 : 		in data port Sensor_Data.impl;
			InputFromSensor3 : 		in data port Sensor_Data.impl;
			InputFromWOWSensor : 	in data port Base_Types::Boolean;
			Output : 				out data port I2H.impl;
		annex agree {**								
			---------------------------------------------------------
			-- S.F.R. 2022/05	
								
			-- QUESTION: is it possible to formulate properties about the likelihood of issuing an alert in range Level1 (resp.2) after an acceptance
			--			 or a rejection by the operator, without technical details about the learning algorithm?		
			guarantee g1 "If the sensor error is in Normal range, then no alert is issued":
			 	(Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Normal) => (not Output.sensor1ErrorData.errorAlert)) and
			 	(Output.sensor2ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Normal) => (not Output.sensor2ErrorData.errorAlert)) and
			 	(Output.sensor3ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Normal) => (not Output.sensor3ErrorData.errorAlert));
			
			guarantee g2 "If the sensor error is in Safety range, then an alert is issued":
			 	(Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Safety) => Output.sensor1ErrorData.errorAlert) and
			 	(Output.sensor2ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Safety) => Output.sensor2ErrorData.errorAlert) and
			 	(Output.sensor3ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Safety) => Output.sensor3ErrorData.errorAlert);			
			---------------------------------------------------------
			
			-----------------------
			--UNRELIABLE SENSOR SCENARIO
			-----------------------

			eq previous_active_sensor : int = prev(Output.Active_Sensor, 1);
			
			eq previous_recommended_sensor : int = prev(Output.Recommended_Sensor, 1);

			eq previous_z_position : real = if (previous_active_sensor = 1) then 
												prev(InputFromSensor1.Position.Z, 0.0)
											else if (previous_active_sensor = 2) then
													prev(InputFromSensor2.Position.Z, 0.0)
												 else --(previous_active_sensor = 3)
												 	prev(InputFromSensor3.Position.Z, 0.0);
			
			eq Horizontal_Threshold : real = Unreliable_Sensor_Lib::HAL(previous_z_position);
			
			eq Vertical_Threshold : real = Unreliable_Sensor_Lib::VAL(previous_z_position);
							
			eq Sensor1_Reliable: bool, Sensor2_Reliable: bool, Sensor3_Reliable: bool = 
				Unreliable_Sensor_Lib::Sensor_Status(InputFromSensor1, InputFromSensor2, InputFromSensor3, Horizontal_Threshold, Vertical_Threshold);
				
			guarantee "Sensor status to operator":
					(Output.Sensor1_Reliable = Sensor1_Reliable)
				and (Output.Sensor2_Reliable = Sensor2_Reliable)
				and (Output.Sensor3_Reliable = Sensor3_Reliable);			
			
			--Should we instead pick one of the three on some other criteria?
			guarantee "Recommended sensor is NIL if and only if all sensors are unreliable":
					Output.Recommended_Sensor = NIL <=> (not Sensor1_Reliable and not Sensor2_Reliable and not Sensor3_Reliable);
			
			guarantee "The recommended sensor is a reliable sensor, unless it is NIL":
					not (Output.Recommended_Sensor = NIL) =>
						(
							   (Output.Recommended_Sensor = 1 and Sensor1_Reliable)
							or (Output.Recommended_Sensor = 2 and Sensor2_Reliable)
							or (Output.Recommended_Sensor = 3 and Sensor3_Reliable)
						);
						
			guarantee "The recommended sensor is the active sensor unless the active sensor has become unreliable":			
					(		(previous_active_sensor = 1 and Output.Sensor1_Reliable)
						or 	(previous_active_sensor = 2 and Output.Sensor2_Reliable)
						or 	(previous_active_sensor = 3 and Output.Sensor3_Reliable)
					)
						=> (Output.Recommended_Sensor = previous_active_sensor);
 
			guarantee "The active sensor should stay the same unless the operator agrees that it is unreliable 
						and there is another reliable sensor available.":
				Output.Active_Sensor = 	
					if (previous_recommended_sensor = NIL)
						then previous_active_sensor
					else if ((previous_active_sensor = 1 and InputFromHuman.Sensor1_Unreliable_Response = enum(Response, Agree))
							  or (previous_active_sensor = 2 and InputFromHuman.Sensor2_Unreliable_Response = enum(Response, Agree))
							  or (previous_active_sensor = 3 and InputFromHuman.Sensor3_Unreliable_Response = enum(Response, Agree)))
						then previous_recommended_sensor
					else previous_active_sensor;
			
--			guarantee "The active sensor should stay the same unless the operator agrees that it is unreliable 
--						and there is another reliable sensor available.":
--				Output.Active_Sensor = 	
--					if (previous_recommended_sensor = NIL) 
--						then previous_active_sensor
--					else if (previous_active_sensor = 1 and InputFromHuman.Sensor1_Unreliable_Response = enum(Response, Agree)) 
--							then previous_recommended_sensor
--						 else if (previous_active_sensor = 2 and InputFromHuman.Sensor2_Unreliable_Response = enum(Response, Agree)) 
--						 		then previous_recommended_sensor
--							  else if (previous_active_sensor = 3 and InputFromHuman.Sensor3_Unreliable_Response = enum(Response, Agree)) 
--							  			then previous_recommended_sensor
--								   else	previous_active_sensor;

			-----------------------
			--FLIGHT PHASE STATE MACHINE
			-----------------------

			-------------------------------------------------------------
			--State machine support macros
									
			eq previous_phase : Phase_Type = prev(Output.Phase, enum(Phase_Type, On_Ground));

			eq some_transition: bool = T_Ground_to_Flight
										or T_Flight_to_Landing
										or T_Landing_to_Ground
										or T_Landing_to_Flight
										or T_Flight_to_Ground;
			-------------------------------------------------------------
			--State transition macros
			
			eq T_Ground_to_Flight: bool = 
				false -> ((previous_phase = enum(Phase_Type, On_Ground)) and not InputFromWOWSensor);
				
			eq T_Flight_to_Landing: bool =
				(previous_phase = enum(Phase_Type, In_Flight)) and InputFromHuman.Initiate_Landing;
			
			--This is not desirable. The pilot should initiate all landings before they occur, but it does seem to be a possible transition.	
			eq T_Flight_to_Ground: bool =
				(previous_phase = enum(Phase_Type, In_Flight)) and InputFromWOWSensor;
				
			eq T_Landing_to_Flight: bool =
				(previous_phase = enum(Phase_Type, Landing)) and InputFromHuman.Abort_Landing;
			
			eq T_Landing_to_Ground: bool =
				(previous_phase = enum(Phase_Type, Landing)) and InputFromWOWSensor;
				
			-------------------------------------------------------------	
			--State machine guarantees	
			
			--This guarantee specifies the initial state.
       		guarantee "Initial_State": (Output.Phase = enum(Phase_Type, On_Ground)) -> true;
        
	        --This guarantee captures all the "self loops" in shorthand form. 
	        -- It is important to state what happens when no transition condition is satisfied.
	        -- Otherwise the model checker will allow "spontaneous" transitions.
	        guarantee "Self loops": not some_transition => (Output.Phase = previous_phase);
        
        	-- Now we write one guarantee for each transition.
         
	        guarantee "T_Ground_to_Flight_effect" : 	T_Ground_to_Flight 	=> (Output.Phase = enum(Phase_Type, In_Flight));
	     
	     	guarantee "T_Flight_to_Landing_effect" : 	T_Flight_to_Landing => (Output.Phase = enum(Phase_Type, Landing));  
	     	
	     	guarantee "T_Flight_to_Ground_effect" : 	T_Flight_to_Ground	=> (Output.Phase = enum(Phase_Type, On_Ground));
	     	
	     	guarantee "T_Landing_to_Flight_effect" :	T_Landing_to_Flight => (Output.Phase = enum(Phase_Type, In_Flight));
	     	
	     	guarantee "T_Landing_to_Ground_effect" : 	T_Landing_to_Ground => (Output.Phase = enum(Phase_Type, On_Ground));
	     	
	     	-----------------------
			--ABORTED LANDING SCENARIO
			-----------------------
			
			guarantee "Landing options should be distinct":
					not (Output.Landing_Options.Option1 = Output.Landing_Options.Option2)
				and not (Output.Landing_Options.Option1 = Output.Landing_Options.Option3)		 								
				and not (Output.Landing_Options.Option2 = Output.Landing_Options.Option3);
				
			guarantee "Present landing options if and only if the landing is aborted":
				T_Landing_to_Flight = Output.Landing_Options_Ready;
				
			guarantee "Destination changes if and only if the pilot selects a landing option":
				true -> (Output.Destination = if pre(Output.Landing_Options_Ready) then 
												InputFromHuman.Landing_Option_Selection 
											  else 
											  	pre(Output.Destination)
				); 
		**};

	end IAS;
	
	---------------------------------------------------------
	-- S.F.R. 2022/05
	
	system implementation IAS.impl
		annex agree {**
			 			
			-- NOTE: observers for the generation of counter-example traces of interest
			 lemma l4 "Observer: if sensor 1 error is in Level1 range, then sometimes an alert is issued":
			 	(Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level1) => (not Output.sensor1ErrorData.errorAlert));
			 lemma l5 "Observer: if sensor 1 error is in Level1 range, then sometimes an alert is not issued":
			 	(Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level1) => Output.sensor1ErrorData.errorAlert);
			 lemma l6 "Observer: if sensor 1 error is in Level2 range, then sometimes an alert is issued":
			 	(Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level2) => (not Output.sensor1ErrorData.errorAlert));
			 lemma l7 "Observer: if sensor 1 error is in Level2 range, then sometimes an alert is not issued":
			 	(Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level2) => Output.sensor1ErrorData.errorAlert);
			 	
			 lemma l8 "Observer: if sensor 2 error is in Level1 range, then sometimes an alert is issued":
			 	(Output.sensor2ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level1) => (not Output.sensor2ErrorData.errorAlert));
			 lemma l9 "Observer: if sensor 2 error is in Level1 range, then sometimes an alert is not issued":
			 	(Output.sensor2ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level1) => Output.sensor2ErrorData.errorAlert);
			 lemma l10 "Observer: if sensor 2 error is in Level2 range, then sometimes an alert is issued":
			 	(Output.sensor2ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level2) => (not Output.sensor2ErrorData.errorAlert));
			 lemma l11 "Observer: if sensor 2 error is in Level2 range, then sometimes an alert is not issued":
			 	(Output.sensor2ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level2) => Output.sensor2ErrorData.errorAlert);
			 	
			 lemma l12 "Observer: if sensor 3 error is in Level1 range, then sometimes an alert is issued":
			 	(Output.sensor3ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level1) => (not Output.sensor3ErrorData.errorAlert));
			 lemma l13 "Observer: if sensor 3 error is in Level1 range, then sometimes an alert is not issued":
			 	(Output.sensor3ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level1) => Output.sensor3ErrorData.errorAlert);
			 lemma l14 "Observer: if sensor 3 error is in Level2 range, then sometimes an alert is issued":
			 	(Output.sensor3ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level2) => (not Output.sensor3ErrorData.errorAlert));
			 lemma l15 "Observer: if sensor 3 error is in Level2 range, then sometimes an alert is not issued":
			 	(Output.sensor3ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level2) => Output.sensor3ErrorData.errorAlert);
			 	
			 -- NOTE: multiple sensors can be arbitrarily erroneous at the same step
			 lemma l16 "Observer: alerts are issued for all sensors at the same step":
			 	not( Output.sensor1ErrorData.errorAlert and
			 		 Output.sensor2ErrorData.errorAlert and
			 		 Output.sensor3ErrorData.errorAlert);
			 		 	
			-- NOTE: how does the notion of sensor error compare with that of reliability (Unreliable_Sensor_Lib)? 
			--		 A sensor error is the deviation of the measured value from the actual value
			--       A position sensor is classified reliable iff its measured position is sufficiently close to that of at least another sensor
			--		 In principle, all sensors can be classified reliable, while being utterly erroneous (high precision vs low accuracy) 
			
			-- PROPERTIES TO BE VALIDATED (AND POSSIBLY ENFORCED):
			--		 If a sensor error is zero (or below a threshold), then the sensor is classified reliable
			--				NOTE: currently not holding, since the two other sensors positions might be equally distant from the only really reliable sensor
			--		 If two sensors errors are zero (or below a threshold), then the two sensors are classified reliable	
			--				NOTE: more in line with the current reliability pairwise evaluation approach
			lemma l17 "Observer: an alert is issued for a sensor classified reliable":
				not( Output.sensor1ErrorData.errorAlert and
					 Output.Sensor1_Reliable );
	
			-- NOTE: currently, a sensor error can arbitrarily fluctuate between Normal and Safety ranges in consecutive steps	
			lemma l18 "Observer: a sensor error range moves from Normal to Safety to Normal in consecutive steps":
				not( prev(prev(Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Normal), false), false) and
					 prev(Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Safety), false) and
					 Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Normal) );
		**};
	---------------------------------------------------------
	end IAS.impl;
	
end IAS;