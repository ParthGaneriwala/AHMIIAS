package Human_IAS_Team
public
	with Human;
	renames Human::all;
	with IAS;
	renames IAS::all;
	with Types_Constants;
	renames Types_Constants::all;
	with Sensors;
	renames Sensors::all;
	
	-------------------------------------
	-- Human-Machine Team
	-------------------------------------
	
	system Team
		annex agree {**
			guarantee "Placeholder gaurantee to get AGREE to run": true;
		**};
	end Team;

	system implementation Team.impl
		subcomponents
			Human: system Human;
			IAS: system IAS.impl; -- S.F.R. 2022/05 changed from IAS to IAS.impl
			Sensor1: system Sensor1;
			Sensor2: system Sensor2;
			Sensor3: system Sensor3;
			WOW_Sensor: system WOW_Sensor;
		connections
			Top_impl_new_connection: feature IAS.Output -> Human.InputFromIAS;
			Top_impl_new_connection2: feature Sensor1.Output -> IAS.InputFromSensor1;
			Top_impl_new_connection3: feature Sensor2.Output -> IAS.InputFromSensor2;
			Top_impl_new_connection4: feature Sensor3.Output -> IAS.InputFromSensor3;
			Top_impl_new_connection5: feature Human.Output -> IAS.InputFromHuman;
			Top_impl_new_connection6: feature Sensor1.Output -> Human.InputFromSensor1;
			Top_impl_new_connection7: feature Sensor2.Output -> Human.InputFromSensor2;
			Top_impl_new_connection8: feature Sensor3.Output -> Human.InputFromSensor3;
			Top_impl_new_connection9: feature WOW_Sensor.Output -> IAS.InputFromWOWSensor;
			Top_impl_new_connection10: feature WOW_Sensor.Output -> Human.InputFromWOWSensor;
		
		annex agree {**
			---------------------------------------------------------
			-- S.F.R. 2022/05	
			
			-- NOTE: observers for the generation of counter-example traces of interest
			lemma l19 "Observer: a sensor 1 error alert is communicated by the system to the operator and 
					             an acceptance response is received back at the next step":
				not( prev(IAS.Output.sensor1ErrorData.errorAlert, false) and
				     prev(Human.InputFromIAS.sensor1ErrorData.errorAlert, false) and  
				     Human.Output.sensor1AlertResponse = enum(Types_Constants::SensorAlertResponse, Accept) and
				     IAS.InputFromHuman.sensor1AlertResponse = enum(Types_Constants::SensorAlertResponse, Accept) );	
				     
 			lemma l20 "Observer: a sensor 2 error alert is communicated by the system to the operator and 
             a reject response is received back at the next step":
				not( prev(IAS.Output.sensor2ErrorData.errorAlert, false) and
				     prev(Human.InputFromIAS.sensor2ErrorData.errorAlert, false) and  
				     Human.Output.sensor2AlertResponse = enum(Types_Constants::SensorAlertResponse, Reject) and
				     IAS.InputFromHuman.sensor2AlertResponse = enum(Types_Constants::SensorAlertResponse, Reject) ); 
				     
			lemma l21 "Observer: no sensor 3 error alert is communicated by the system to the operator and 
              no response is received back at the next step":
				not( prev(not IAS.Output.sensor3ErrorData.errorAlert, false) and
				     prev(not Human.InputFromIAS.sensor3ErrorData.errorAlert, false) and  
				     Human.Output.sensor3AlertResponse = enum(Types_Constants::SensorAlertResponse, None) and
				     IAS.InputFromHuman.sensor3AlertResponse = enum(Types_Constants::SensorAlertResponse, None) );
			---------------------------------------------------------	
			
			--------------------------------------------
			-- EQ (STATE VARIABLES)
			--------------------------------------------
			eq previous_active_sensor : int = prev(IAS.Output.Active_Sensor, 1);
			eq previous_recommended_sensor : int = prev(IAS.Output.Recommended_Sensor, 1);
			eq reliable_sensor_available : bool = IAS.Output.Sensor1_Reliable or IAS.Output.Sensor2_Reliable or IAS.Output.Sensor3_Reliable;
			--------------------------------------------
			-- OBSERVERS (We want these to be invalid.)
			--------------------------------------------
			lemma "Observer: Operator agrees that Sensor 1 is unreliable":
													not (Human.Output.Sensor1_Unreliable_Response = enum(Response, Agree));
			lemma "Observer: IAS flags Sensor 1 unreliable":
													IAS.Output.Sensor1_Reliable;
			lemma "Observer: All sensors reliable":
													not (	IAS.Output.Sensor1_Reliable
														and IAS.Output.Sensor2_Reliable
														and IAS.Output.Sensor3_Reliable);
			lemma "Observer: All sensors unreliable":
														IAS.Output.Sensor1_Reliable
													or 	IAS.Output.Sensor2_Reliable
													or 	IAS.Output.Sensor3_Reliable;
			lemma "Observer: The active sensor changes":
													IAS.Output.Active_Sensor = prev(IAS.Output.Active_Sensor,1);
													
			--Check that all states are reachable
			lemma "Observer: On_Ground reachable" : not (IAS.Output.Phase = enum(Phase_type, On_Ground));
			lemma "Observer: In_Flight reachable" : not (IAS.Output.Phase = enum(Phase_type, In_Flight));
			lemma "Observer: Landing reachable" : not (IAS.Output.Phase = enum(Phase_type, Landing));
			
			--Check that all state transitions are reachable
			lemma "Observer: T_Ground_to_Flight is reachable" : not IAS.T_Ground_to_Flight;
			lemma "Observer: T_Flight_to_Landing is reachable" : not IAS.T_Flight_to_Landing;
			lemma "Observer: T_Landing_to_Ground is reachable" : not IAS.T_Landing_to_Ground;
			lemma "Observer: T_Landing_to_Flight is reachable" : not IAS.T_Landing_to_Flight;
			lemma "Observer: T_Flight_to_Ground is reachable" : not IAS.T_Flight_to_Ground;
			
			lemma "Observer: Destination changes" : true -> (IAS.Output.Destination = pre(IAS.Output.Destination)); 
			
			------------------------------------------------------------------------------
			-- LEMMAS (These should be true based on the guarantees of the subcomponents.)
			------------------------------------------------------------------------------
			lemma "Operator responds to unreliable sensor alerts": 
					(prev(not IAS.Output.Sensor1_Reliable, false) <=> ((Human.Output.Sensor1_Unreliable_Response = enum(Response, Agree)) or (Human.Output.Sensor1_Unreliable_Response = enum(Response, Disagree))))
				and (prev(not IAS.Output.Sensor2_Reliable, false) <=> ((Human.Output.Sensor2_Unreliable_Response = enum(Response, Agree)) or (Human.Output.Sensor2_Unreliable_Response = enum(Response, Disagree))))
				and (prev(not IAS.Output.Sensor3_Reliable, false) <=> ((Human.Output.Sensor3_Unreliable_Response = enum(Response, Agree)) or (Human.Output.Sensor3_Unreliable_Response = enum(Response, Disagree))));
			
			lemma "We can't have just Sensor 1 reliable":
					not (	 IAS.Output.Sensor1_Reliable and not IAS.Output.Sensor2_Reliable and not IAS.Output.Sensor3_Reliable);
			
			lemma "We can't have just Sensor 2 reliable":
					not (not IAS.Output.Sensor1_Reliable and 	 IAS.Output.Sensor2_Reliable and not IAS.Output.Sensor3_Reliable);
			
			lemma "We can't have just Sensor 3 reliable":
					not (not IAS.Output.Sensor1_Reliable and not IAS.Output.Sensor2_Reliable and 	 IAS.Output.Sensor3_Reliable);
			
			lemma "Unless the active sensor becomes unreliable, 
					the recommended sensor is the current active sensor":
					(		(previous_active_sensor = 1 and IAS.Output.Sensor1_Reliable)
						or 	(previous_active_sensor = 2 and IAS.Output.Sensor2_Reliable)
						or 	(previous_active_sensor = 3 and IAS.Output.Sensor3_Reliable))
					=> (IAS.Output.Recommended_Sensor = previous_active_sensor);
			
			lemma "If the operator agrees that the active sensor is unreliable, 
					the new active sensor is the previously recommended sensor, 
					unless the previously recommended sensor was NIL":
					previous_recommended_sensor != NIL =>
						(	((previous_active_sensor = 1 and Human.Output.Sensor1_Unreliable_Response = enum(Response, Agree)) => 
							IAS.Output.Active_Sensor = previous_recommended_sensor
							)
						and ((previous_active_sensor = 2 and Human.Output.Sensor2_Unreliable_Response = enum(Response, Agree)) => 
							IAS.Output.Active_Sensor = previous_recommended_sensor
							)
						and ((previous_active_sensor = 3 and Human.Output.Sensor3_Unreliable_Response = enum(Response, Agree)) => 
							IAS.Output.Active_Sensor = previous_recommended_sensor
							)
						);
			lemma "If the operator disagrees that the active sensor is unreliable, then the active sensor should not change.":
					(	(previous_active_sensor = 1 and Human.Output.Sensor1_Unreliable_Response = enum(Response, Disagree))
					or  (previous_active_sensor = 2 and Human.Output.Sensor2_Unreliable_Response = enum(Response, Disagree))
					or 	(previous_active_sensor = 3 and Human.Output.Sensor3_Unreliable_Response = enum(Response, Disagree))
					) 
					=>
					IAS.Output.Active_Sensor = previous_active_sensor;
			
			lemma "If an unreliable sensor is the active sensor, it must be the case that either 
					the pilot disagreed with the IAS assessment 
					or the sensor just became unreliable on this timestep 
					or there was no reliable sensor available on the previous timestep":
						((IAS.Output.Active_Sensor = 1) and not IAS.Output.Sensor1_Reliable) 
							=>  (	(Human.Output.Sensor1_Unreliable_Response = enum(Response, Disagree)) 
								or 	prev(IAS.Output.Sensor1_Reliable, true) 
								or not prev(reliable_sensor_available, true)
								)
					and ((IAS.Output.Active_Sensor = 2) and not IAS.Output.Sensor2_Reliable) 
							=>  (	(Human.Output.Sensor2_Unreliable_Response = enum(Response, Disagree)) 
								or 	prev(IAS.Output.Sensor2_Reliable, true) 
								or 	not prev(reliable_sensor_available, true)
								)
					and ((IAS.Output.Active_Sensor = 3) and not IAS.Output.Sensor3_Reliable) 
							=>  (	(Human.Output.Sensor3_Unreliable_Response = enum(Response, Disagree)) 
								or 	prev(IAS.Output.Sensor3_Reliable, true) 
								or not prev(reliable_sensor_available, true)
							);
			
			lemma "If Sensor 1 is both the active sensor and unreliable, it must be the case that either
				the pilot disagreed with the IAS assessment 
				or the sensor just became unreliable on this timestep 
				or there was no reliable sensor available on the previous timestep":
						((IAS.Output.Active_Sensor = 1) and not IAS.Output.Sensor1_Reliable) 
							=>  (	(Human.Output.Sensor1_Unreliable_Response = enum(Response, Disagree)) 
								or 	prev(IAS.Output.Sensor1_Reliable, true) 
								or not prev(reliable_sensor_available, true));
			
			lemma "Active sensor in range":
				IAS.Output.Active_Sensor >= 1 and IAS.Output.Active_Sensor <= 3;
			
			lemma "Recommended active sensor in range":
				IAS.Output.Recommended_Sensor >= 0 and IAS.Output.Recommended_Sensor <= 3;
														
			lemma "Only stated transitions are allowed." :
				IAS.some_transition or (IAS.Output.Phase = IAS.previous_phase);
			
			------------------------------------------------------------------------------
			-- INVALID LEMMAS (These are notably invalid.)
			------------------------------------------------------------------------------
			
			lemma "Invalid (because the operator may disagree): The active sensor is always a reliable sensor (on the previous timestep) when a reliable sensor is available":
				true -> (pre(reliable_sensor_available)
						=>
						(	(IAS.Output.Active_Sensor = 1 => pre(IAS.Output.Sensor1_Reliable))
						and (IAS.Output.Active_Sensor = 2 => pre(IAS.Output.Sensor2_Reliable))
						and (IAS.Output.Active_Sensor = 3 => pre(IAS.Output.Sensor3_Reliable))));
		**};
		
	end Team.impl;
		
end Human_IAS_Team;
