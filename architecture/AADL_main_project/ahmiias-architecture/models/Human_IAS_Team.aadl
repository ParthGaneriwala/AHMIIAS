package Human_IAS_Team
public
	with Human;
	renames Human::all;
	with IAS;
	renames IAS::all;
	with Types_Constants;
	renames Types_Constants::all;
	with Sensors;
	renames Sensors::all;
	
	-------------------------------------
	-- Human-Machine Team
	-------------------------------------
	
	system Team
		annex agree {**
			guarantee t_g "Placeholder guarantee to get AGREE to run": true;
		**};
	end Team;

	system implementation Team.impl
		subcomponents
			Human: system Human;
			IAS: system IAS;
			Sensor1: system Sensor1;
			Sensor2: system Sensor2;
			Sensor3: system Sensor3;
			WOW_Sensor: system WOW_Sensor;
		connections
			Top_impl_new_connection: feature IAS.Output -> Human.InputFromIAS;
			Top_impl_new_connection2: feature Sensor1.Output -> IAS.InputFromSensor1;
			Top_impl_new_connection3: feature Sensor2.Output -> IAS.InputFromSensor2;
			Top_impl_new_connection4: feature Sensor3.Output -> IAS.InputFromSensor3;
			Top_impl_new_connection5: feature Human.Output -> IAS.InputFromHuman;
			Top_impl_new_connection6: feature Sensor1.Output -> Human.InputFromSensor1;
			Top_impl_new_connection7: feature Sensor2.Output -> Human.InputFromSensor2;
			Top_impl_new_connection8: feature Sensor3.Output -> Human.InputFromSensor3;
			Top_impl_new_connection9: feature WOW_Sensor.Output -> IAS.InputFromWOWSensor;
			Top_impl_new_connection10: feature WOW_Sensor.Output -> Human.InputFromWOWSensor;
			

		annex safety {**
			analyze : max 1 fault
		**};
		
		annex agree {**
			
			 -- NOTE: observers for the generation of counter-example traces of interest in the operator-IAS interaction
			 lemma t_l01 "Observer: a sensor 1 unreliability alert is communicated by the IAS to the operator and 
					   an agreement response is communicated by the operator at the next step":
				not( prev(IAS.Output.sensor1ErrorData.unreliable, false) and
				     Human.Output.sensor1UnreliableResponse = enum(Types_Constants::Response, Agree) );	
				     
 			 lemma t_l02 "Observer: a sensor 2 unreliability alert is communicated by the IAS to the operator and 
             		   a disagreement response is communicated by the operator at the next step":
				not( prev(IAS.Output.sensor2ErrorData.unreliable, false) and
				     Human.Output.sensor2UnreliableResponse = enum(Types_Constants::Response, Disagree) ); 
				     
			 lemma t_l03 "Observer: no sensor 3 unreliability alert is communicated by the IAS to the operator and 
              		   no response is communicated by the operator at the next step":
				not( prev(not IAS.Output.sensor3ErrorData.unreliable, false) and 
				     Human.Output.sensor3UnreliableResponse = enum(Types_Constants::Response, Neutral) );
			
			-- NOTE: observers for the generation of counter-example traces of interest in the IAS
			 lemma t_l04 "Observer: if sensor 1 error is in Level1 range, then sometimes an unreliability alert is issued":
			 	(IAS.Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level1) 
			 		=> (not IAS.Output.sensor1ErrorData.unreliable));
			 lemma t_l05 "Observer: if sensor 1 error is in Level1 range, then sometimes an unreliability alert is not issued":
			 	(IAS.Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level1) 
			 		=> IAS.Output.sensor1ErrorData.unreliable);
			 lemma t_l06 "Observer: if sensor 1 error is in Level2 range, then sometimes an unreliability alert is issued":
			 	(IAS.Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level2) 
			 		=> (not IAS.Output.sensor1ErrorData.unreliable));
			 lemma t_l07 "Observer: if sensor 1 error is in Level2 range, then sometimes an unreliability alert is not issued":
			 	(IAS.Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level2) 
			 		=> IAS.Output.sensor1ErrorData.unreliable);
			 	
			 lemma t_l08 "Observer: if sensor 2 error is in Level1 range, then sometimes an unreliability alert is issued":
			 	(IAS.Output.sensor2ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level1) 
			 		=> (not IAS.Output.sensor2ErrorData.unreliable));
			 lemma t_l09 "Observer: if sensor 2 error is in Level1 range, then sometimes an unreliability alert is not issued":
			 	(IAS.Output.sensor2ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level1) 
			 		=> IAS.Output.sensor2ErrorData.unreliable);
			 lemma t_l10 "Observer: if sensor 2 error is in Level2 range, then sometimes an unreliability alert is issued":
			 	(IAS.Output.sensor2ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level2) 
			 		=> (not IAS.Output.sensor2ErrorData.unreliable));
			 lemma t_l11 "Observer: if sensor 2 error is in Level2 range, then sometimes an unreliability alert is not issued":
			 	(IAS.Output.sensor2ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level2) 
			 		=> IAS.Output.sensor2ErrorData.unreliable);
			 	
			 lemma t_l12 "Observer: if sensor 3 error is in Level1 range, then sometimes an unreliability alert is issued":
			 	(IAS.Output.sensor3ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level1) 
			 		=> (not IAS.Output.sensor3ErrorData.unreliable));
			 lemma t_l13 "Observer: if sensor 3 error is in Level1 range, then sometimes an unreliability alert is not issued":
			 	(IAS.Output.sensor3ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level1) 
			 		=> IAS.Output.sensor3ErrorData.unreliable);
			 lemma t_l14 "Observer: if sensor 3 error is in Level2 range, then sometimes an unreliability alert is issued":
			 	(IAS.Output.sensor3ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level2) 
			 		=> (not IAS.Output.sensor3ErrorData.unreliable));
			 lemma t_l15 "Observer: if sensor 3 error is in Level2 range, then sometimes an unreliability alert is not issued":
			 	(IAS.Output.sensor3ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Level2) 
			 		=> IAS.Output.sensor3ErrorData.unreliable);
			 	
			 -- NOTE: multiple sensors can be arbitrarily erroneous at the same step
			 lemma t_l16 "Observer: unreliability alerts are issued for all sensors at the same step":
			 	not( IAS.Output.sensor1ErrorData.unreliable and
			 		 IAS.Output.sensor2ErrorData.unreliable and
			 		 IAS.Output.sensor3ErrorData.unreliable);
			 		 		 		 				
			 -- NOTE: a sensor error can arbitrarily fluctuate between Normal and Safety ranges in consecutive steps	
			 lemma t_l18 "Observer: a sensor error range can move from Normal to Safety to Normal in consecutive steps":
					not( prev(prev(IAS.Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Normal), false), false) and
					 	prev(IAS.Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Safety), false) and
					 	IAS.Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Normal) )
				and not( prev(prev(IAS.Output.sensor2ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Normal), false), false) and
					 	prev(IAS.Output.sensor2ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Safety), false) and
					 	IAS.Output.sensor2ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Normal) )
				and not( prev(prev(IAS.Output.sensor3ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Normal), false), false) and
					 	prev(IAS.Output.sensor3ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Safety), false) and
					 	IAS.Output.sensor3ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Normal) );
			 		
			--------------------------------------------
			-- EQ (STATE VARIABLES)
			--------------------------------------------
			eq previous_active_sensor 		: int = prev(IAS.Output.Active_Sensor, 1);
			eq previous_recommended_sensor 	: int = prev(IAS.Output.Recommended_Sensor, 1);
			eq reliable_sensor_available 	: bool = 		(not IAS.Output.sensor1ErrorData.unreliable)
														or  (not IAS.Output.sensor2ErrorData.unreliable)
														or  (not IAS.Output.sensor3ErrorData.unreliable);
			--------------------------------------------
			-- OBSERVERS (We want these to be invalid.)
			--------------------------------------------
			lemma t_l21 "Observer: Operator agrees that Sensor 1 is unreliable":
													not (Human.Output.sensor1UnreliableResponse = enum(Response, Agree));
			lemma t_l22 "Observer: IAS flags Sensor 1 unreliable":
													not IAS.Output.sensor1ErrorData.unreliable;
			lemma t_l23 "Observer: All sensors reliable":
													not (   (not IAS.Output.sensor1ErrorData.unreliable)
														and (not IAS.Output.sensor2ErrorData.unreliable)
														and (not IAS.Output.sensor3ErrorData.unreliable));
			lemma t_l24 "Observer: All sensors unreliable":
													not(	IAS.Output.sensor1ErrorData.unreliable
														and IAS.Output.sensor1ErrorData.unreliable
														and IAS.Output.sensor1ErrorData.unreliable);
			lemma t_l25 "Observer: The active sensor changes":
													IAS.Output.Active_Sensor = prev(IAS.Output.Active_Sensor,1);
													
			--Check that all states are reachable
			lemma t_l26 "Observer: On_Ground reachable" : not (IAS.Output.Phase = enum(Phase_type, On_Ground));
			lemma t_l27 "Observer: In_Flight reachable" : not (IAS.Output.Phase = enum(Phase_type, In_Flight));
			lemma t_l28 "Observer: Landing reachable" : not (IAS.Output.Phase = enum(Phase_type, Landing));
			
			--Check that all state transitions are reachable
			lemma t_l29 "Observer: T_Ground_to_Flight is reachable" : not IAS.T_Ground_to_Flight;
			lemma t_l30 "Observer: T_Flight_to_Landing is reachable" : not IAS.T_Flight_to_Landing;
			lemma t_l31 "Observer: T_Landing_to_Ground is reachable" : not IAS.T_Landing_to_Ground;
			lemma t_l32 "Observer: T_Landing_to_Flight is reachable" : not IAS.T_Landing_to_Flight;
			lemma t_l33 "Observer: T_Flight_to_Ground is reachable" : not IAS.T_Flight_to_Ground;
			
			lemma t_l34 "Observer: Destination changes" : true -> (IAS.Output.Destination = pre(IAS.Output.Destination)); 
			
			------------------------------------------------------------------------------
			-- LEMMAS (These should be true based on the guarantees of the subcomponents.)
			------------------------------------------------------------------------------
			
			 lemma t_l20 "If sensor 1 error is in Normal range, then no sensor 1 unreliability alert is issued":
			 	(IAS.Output.sensor1ErrorData.errorRange = enum(Types_Constants::SensorErrorRange, Normal) 
			 		=> (not IAS.Output.sensor1ErrorData.unreliable));
			 		
			-- NOTE: lemma becomes invalid when fault nondet_sensor1_unreliability (see IAS.aadl) is enabled
			--       or when fault no_sensor1_unreliability_response (see Human.aadl) is enabled
			lemma t_l35 "Operator responds to sensor unreliability alerts": 
					(prev(IAS.Output.sensor1ErrorData.unreliable, false) <=> 
					 (	 (Human.Output.sensor1UnreliableResponse = enum(Response, Agree)) 
					  or (Human.Output.sensor1UnreliableResponse = enum(Response, Disagree))
					 ))
				and (prev(IAS.Output.sensor2ErrorData.unreliable, false) <=> 
					 (	 (Human.Output.sensor2UnreliableResponse = enum(Response, Agree))
					  or (Human.Output.sensor2UnreliableResponse = enum(Response, Disagree))
					 ))
				and (prev(IAS.Output.sensor3ErrorData.unreliable, false) <=> 
					 (	 (Human.Output.sensor3UnreliableResponse = enum(Response, Agree))
					  or (Human.Output.sensor3UnreliableResponse = enum(Response, Disagree))
					 ));
			
			---------------------------------------------------------
			-- S.F.R. 2022/07
			
			-- NOTE: not valid anymore, since two sensors errors might be in range Level1 or 2,
			-- while only one of the two sensors is reported as unreliable
			--lemma t_l36 "We can't have just Sensor 1 reliable":
			--		not ((not IAS.Output.sensor1ErrorData.unreliable) 
			--			 and IAS.Output.sensor2ErrorData.unreliable
			--			 and IAS.Output.sensor3ErrorData.unreliable);
			
			--lemma t_l37 "We can't have just Sensor 2 reliable":
			--		not ((not IAS.Output.sensor2ErrorData.unreliable) 
			--			 and IAS.Output.sensor1ErrorData.unreliable
			--			 and IAS.Output.sensor3ErrorData.unreliable);
						 			
			--lemma t_l38 "We can't have just Sensor 3 reliable":
			--		not ((not IAS.Output.sensor3ErrorData.unreliable) 
			--			 and IAS.Output.sensor1ErrorData.unreliable
			--			 and IAS.Output.sensor2ErrorData.unreliable);
			---------------------------------------------------------
						 			
			-- NOTE: lemma becomes invalid when fault nondet_sensor1_unreliability (see IAS.aadl) is enabled
			lemma t_l39 "Unless the active sensor becomes unreliable, 
					the recommended sensor is the current active sensor":
					(		(previous_active_sensor = 1 and (not IAS.Output.sensor1ErrorData.unreliable))
						or 	(previous_active_sensor = 2 and (not IAS.Output.sensor2ErrorData.unreliable))
						or 	(previous_active_sensor = 3 and (not IAS.Output.sensor3ErrorData.unreliable)))
					=> (IAS.Output.Recommended_Sensor = previous_active_sensor);
			
			lemma t_l40 "If the operator agrees that the active sensor is unreliable, 
					the new active sensor is the previously recommended sensor, 
					unless the previously recommended sensor was NIL":
					(previous_recommended_sensor != NIL) =>
						(	((previous_active_sensor = 1 and Human.Output.sensor1UnreliableResponse = enum(Response, Agree)) => 
							IAS.Output.Active_Sensor = previous_recommended_sensor
							)
						and ((previous_active_sensor = 2 and Human.Output.sensor2UnreliableResponse = enum(Response, Agree)) => 
							IAS.Output.Active_Sensor = previous_recommended_sensor
							)
						and ((previous_active_sensor = 3 and Human.Output.sensor3UnreliableResponse = enum(Response, Agree)) => 
							IAS.Output.Active_Sensor = previous_recommended_sensor
							)
						);
						
			lemma t_l41 "If the operator disagrees that the active sensor is unreliable, then the active sensor should not change.":
					(	(previous_active_sensor = 1 and Human.Output.sensor1UnreliableResponse = enum(Response, Disagree))
					or  (previous_active_sensor = 2 and Human.Output.sensor2UnreliableResponse = enum(Response, Disagree))
					or 	(previous_active_sensor = 3 and Human.Output.sensor3UnreliableResponse = enum(Response, Disagree))
					) 
					=>
					IAS.Output.Active_Sensor = previous_active_sensor;
			
			---------------------------------------------------------
			-- S.F.R. 2022/07
			
			-- NOTE: 
			-- 1) t_l42 is the original formulation. It becomes invalid when fault no_sensor1_unreliability_response (see Human.aadl) 
			--	  is enabled, but its validity is restored when IAS guarantee ias_g7 is refined into ias_g8 (see IAS.aadl) 
			-- 2) t_l42 becomes invalid again, in presence of the fault, when IAS guarantee ias_g8 is refined into ias_g20: 
			--    in fact, an unreliable sensor can remain active also if the sensor error is in Level 1 or 2 range and the operator 
			--	  does not respond to the unreliability alert. 
			--    t_l43 is introduced as a refinement of t_l42; t_l43 is valid in combination with ias_g20 
			
			lemma t_l42 "If an unreliable sensor is the active sensor, it must be the case that either 
					the pilot disagreed with the IAS assessment 
					or the sensor just became unreliable on this timestep 
					or there was no reliable sensor available on the previous timestep":
						(((IAS.Output.Active_Sensor = 1) and IAS.Output.sensor1ErrorData.unreliable) 
							=>  (	Human.Output.sensor1UnreliableResponse = enum(Response, Disagree)
								or 	prev(not IAS.Output.sensor1ErrorData.unreliable, true) 
								or  not prev(reliable_sensor_available, true)
								))
					and (((IAS.Output.Active_Sensor = 2) and IAS.Output.sensor2ErrorData.unreliable) 
							=>  (	Human.Output.sensor2UnreliableResponse = enum(Response, Disagree) 
								or 	prev(not IAS.Output.sensor2ErrorData.unreliable, true) 
								or 	not prev(reliable_sensor_available, true)
								))
					and (((IAS.Output.Active_Sensor = 3) and IAS.Output.sensor3ErrorData.unreliable) 
							=>  (	Human.Output.sensor3UnreliableResponse = enum(Response, Disagree) 
								or 	prev(not IAS.Output.sensor3ErrorData.unreliable, true) 
								or  not prev(reliable_sensor_available, true)
							));
							
			eq previous_sensor1_error_range : SensorErrorRange = 
				prev(IAS.Output.sensor1ErrorData.errorRange, enum(Types_Constants::SensorErrorRange, Normal));
			eq previous_sensor2_error_range : SensorErrorRange = 
				prev(IAS.Output.sensor2ErrorData.errorRange, enum(Types_Constants::SensorErrorRange, Normal));
			eq previous_sensor3_error_range : SensorErrorRange = 
				prev(IAS.Output.sensor3ErrorData.errorRange, enum(Types_Constants::SensorErrorRange, Normal));
							
			lemma t_l43 "If an unreliable sensor is the active sensor, it must be the case that either 
					the pilot disagreed with the IAS assessment 
					or the pilot did not respond
					or the sensor just became unreliable on this timestep 
					or there was no reliable sensor available on the previous timestep":
						(((IAS.Output.Active_Sensor = 1) and IAS.Output.sensor1ErrorData.unreliable) 
							=>  (	Human.Output.sensor1UnreliableResponse = enum(Response, Disagree)
								or  ( 	  Human.Output.sensor1UnreliableResponse = enum(Response, Neutral) 
									  and (   previous_sensor1_error_range = enum(Types_Constants::SensorErrorRange, Level1)
									       or previous_sensor1_error_range = enum(Types_Constants::SensorErrorRange, Level2)))
								or 	prev(not IAS.Output.sensor1ErrorData.unreliable, true) 
								or  not prev(reliable_sensor_available, true)
								))
					and (((IAS.Output.Active_Sensor = 2) and IAS.Output.sensor2ErrorData.unreliable) 
							=>  (	Human.Output.sensor2UnreliableResponse = enum(Response, Disagree) 
								or  ( 	  Human.Output.sensor2UnreliableResponse = enum(Response, Neutral) 
									  and (   previous_sensor2_error_range = enum(Types_Constants::SensorErrorRange, Level1)
									       or previous_sensor2_error_range = enum(Types_Constants::SensorErrorRange, Level2)))
								or 	prev(not IAS.Output.sensor2ErrorData.unreliable, true) 
								or 	not prev(reliable_sensor_available, true)
								))
					and (((IAS.Output.Active_Sensor = 3) and IAS.Output.sensor3ErrorData.unreliable) 
							=>  (	Human.Output.sensor3UnreliableResponse = enum(Response, Disagree)
								or  ( 	  Human.Output.sensor3UnreliableResponse = enum(Response, Neutral) 
									  and (   previous_sensor3_error_range = enum(Types_Constants::SensorErrorRange, Level1)
									       or previous_sensor3_error_range = enum(Types_Constants::SensorErrorRange, Level2)))
								or 	prev(not IAS.Output.sensor3ErrorData.unreliable, true) 
								or  not prev(reliable_sensor_available, true)
							));
			
			lemma t_l48 "Sensor errors are always non-negative" :
					IAS.Output.sensor1ErrorData.error >= 0.0
				and IAS.Output.sensor2ErrorData.error >= 0.0
				and IAS.Output.sensor3ErrorData.error >= 0.0;				
			---------------------------------------------------------

			lemma t_l44 "Active sensor in range":
				IAS.Output.Active_Sensor >= 1 and IAS.Output.Active_Sensor <= 3;
			
			lemma t_l45 "Recommended active sensor in range":
				IAS.Output.Recommended_Sensor >= 0 and IAS.Output.Recommended_Sensor <= 3;
														
			lemma t_l46 "Only stated transitions are allowed." :
				IAS.some_transition or (IAS.Output.Phase = IAS.previous_phase);
				
			------------------------------------------------------------------------------
			-- INVALID LEMMAS (These are notably invalid.)
			------------------------------------------------------------------------------
			
			lemma t_l47 "Invalid (because the operator may disagree): The active sensor is always a reliable sensor (on the previous timestep) when a reliable sensor is available":
				true -> (pre(reliable_sensor_available)
						=>
						(	(IAS.Output.Active_Sensor = 1 => pre(not IAS.Output.sensor1ErrorData.unreliable))
						and (IAS.Output.Active_Sensor = 2 => pre(not IAS.Output.sensor2ErrorData.unreliable))
						and (IAS.Output.Active_Sensor = 3 => pre(not IAS.Output.sensor3ErrorData.unreliable))));
						
			lemma t_l49 "If the active sensor is reliable, then the active sensor is not changed to an unreliable sensor":
				((prev(IAS.Output.Active_Sensor, 1) = 1) and (not IAS.Output.sensor1ErrorData.unreliable))
				=>
				(not (		(IAS.Output.Active_Sensor = 2 and (IAS.Output.sensor2ErrorData.unreliable))
						or	(IAS.Output.Active_Sensor = 3 and (IAS.Output.sensor3ErrorData.unreliable))));
		**};
		
	end Team.impl;
		
end Human_IAS_Team;
