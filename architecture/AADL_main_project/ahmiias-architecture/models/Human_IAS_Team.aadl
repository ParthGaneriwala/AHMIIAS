package Human_IAS_Team
public
	with Types_Constants;
	renames Types_Constants::all;
	with Unreliable_Sensor_Lib;	
	with Base_Types;

	-------------------------------------
	-- Human
	-------------------------------------
	
	system Human
		features
			InputFromIAS : in data port I2H.impl;
			InputFromSensor1 : in data port Sensor_Data.impl;
			InputFromSensor2 : in data port Sensor_Data.impl;
			InputFromSensor3 : in data port Sensor_Data.impl;
			InputFromWOWSensor : in data port Base_Types::Boolean;
			Output : out data port H2I.impl;
			---------------------------------------------------------
			-- S.F.R. 2022/05
			sensor1AlertFromIAS : in data port SensorAlertData.impl;
			sensor2AlertFromIAS : in data port SensorAlertData.impl;
			sensor3AlertFromIAS : in data port SensorAlertData.impl;
			sensor1AlertResponseToIAS : out data port SensorAlertResponse;
			sensor2AlertResponseToIAS : out data port SensorAlertResponse;
			sensor3AlertResponseToIAS : out data port SensorAlertResponse;
			---------------------------------------------------------
		annex agree {**
			---------------------------------------------------------
			-- S.F.R. 2022/05
			
			-- NOTE: arbitrary delays between alert reception and response to be tested
			-- NOTE: at least one step to avoid the presence of an algebraic loop in the communication between system and operator
			guarantee g1 "If a sensor 1 alert is received by operator, then an alert response is communicated by the operator at the next step":
				(prev(sensor1AlertFromIAS.sensorErrorAlert, false))
				<=> (sensor1AlertResponseToIAS = enum(Types_Constants::SensorAlertResponse, Accept) or 
					 sensor1AlertResponseToIAS = enum(Types_Constants::SensorAlertResponse, Reject)
				);
			guarantee g2 "If no sensor 1 alert is received by the operator, then no alert response is communicated by the operator at the next step":
			(prev(not sensor1AlertFromIAS.sensorErrorAlert, true))
				<=> (sensor1AlertResponseToIAS = enum(Types_Constants::SensorAlertResponse, None));
				
			guarantee g3 "If a sensor 2 alert is received by the operator, then an alert response is communicated by the operator at the next step":
				(prev(sensor2AlertFromIAS.sensorErrorAlert, false))
				<=> (sensor2AlertResponseToIAS = enum(Types_Constants::SensorAlertResponse, Accept) or 
					 sensor1AlertResponseToIAS = enum(Types_Constants::SensorAlertResponse, Reject)
				);
			guarantee g4 "If no sensor 2 alert is received by the operator, then no alert response is communicated by the operator at the next step":
			(prev(not sensor2AlertFromIAS.sensorErrorAlert, true))
				<=> (sensor2AlertResponseToIAS = enum(Types_Constants::SensorAlertResponse, None));
				
			guarantee g5 "If a sensor 3 alert is received by the operator, then an alert response is communicated by the operator at the next step":
				(prev(sensor3AlertFromIAS.sensorErrorAlert, false))
				<=> (sensor3AlertResponseToIAS = enum(Types_Constants::SensorAlertResponse, Accept) or 
					 sensor1AlertResponseToIAS = enum(Types_Constants::SensorAlertResponse, Reject)
				);
			guarantee g6 "If no sensor 3 alert is received by the operator, then no alert response is communicated by the operator at the next step":
			(prev(not sensor3AlertFromIAS.sensorErrorAlert, true))
				<=> (sensor3AlertResponseToIAS = enum(Types_Constants::SensorAlertResponse, None));
			---------------------------------------------------------
			

			-----------------------
			--GUARANTEES RELATED TO THE UNRELIABLE SENSOR SCENARIO
			-----------------------
				
			guarantee "Respond to message that Sensor1 is unreliable":
				prev(not InputFromIAS.Sensor1_Reliable, false) <=> 
					((Output.Sensor1_Unreliable_Response = enum(Response, Agree)) 
						or (Output.Sensor1_Unreliable_Response = enum(Response, Disagree))
					); 
			
			guarantee "Respond to message that Sensor2 is unreliable":
				prev(not InputFromIAS.Sensor2_Reliable, false) <=> 
					((Output.Sensor2_Unreliable_Response = enum(Response, Agree)) 
						or (Output.Sensor2_Unreliable_Response = enum(Response, Disagree))
					);
			
			guarantee "Respond to message that Sensor3 is unreliable":
				prev(not InputFromIAS.Sensor3_Reliable, false) <=> 
					((Output.Sensor3_Unreliable_Response = enum(Response, Agree)) 
						or (Output.Sensor3_Unreliable_Response = enum(Response, Disagree))
					);					

			-----------------------
			--GUARANTEES RELATED TO THE ABORTED LANDING SCENARIO
			-----------------------
			
			guarantee "Command initiate landing only if aircraft is in the flight phase (may be enforced by display)":
				Output.Initiate_Landing => prev((InputFromIAS.Phase = enum(Phase_Type, In_Flight)), false);
			
			guarantee "Command abort landing only if aircraft is in the landing phase (may be enforced by display)":
				Output.Abort_Landing => prev((InputFromIAS.Phase = enum(Phase_Type, Landing)), false); 
				
			guarantee "Choose a landing option when they are ready":
				true -> (pre(InputFromIAS.Landing_Options_Ready) => 
							(   (Output.Landing_Option_Selection = pre(InputFromIAS.Landing_Options.Option1))
							or  (Output.Landing_Option_Selection = pre(InputFromIAS.Landing_Options.Option2))
							or  (Output.Landing_Option_Selection = pre(InputFromIAS.Landing_Options.Option3))
							)
						); 
						
		**};
	end Human;
	
	-------------------------------------
	-- IAS
	-------------------------------------
	
	system IAS
		features
			InputFromHuman : in data port H2I.impl;
			InputFromSensor1 : in data port Sensor_Data.impl;
			InputFromSensor2 : in data port Sensor_Data.impl;
			InputFromSensor3 : in data port Sensor_Data.impl;
			InputFromWOWSensor : in data port Base_Types::Boolean;
			Output : out data port I2H.impl;
			---------------------------------------------------------
			-- S.F.R. 2022/05
			sensor1AlertResponseFromHuman : in data port SensorAlertResponse;
			sensor2AlertResponseFromHuman : in data port SensorAlertResponse;
			sensor3AlertResponseFromHuman : in data port SensorAlertResponse;
			sensor1AlertToHuman : out data port SensorAlertData.impl;
			sensor2AlertToHuman : out data port SensorAlertData.impl;
			sensor3AlertToHuman : out data port SensorAlertData.impl;
			---------------------------------------------------------
		annex agree {**
			
			-----------------------
			--UNRELIABLE SENSOR SCENARIO
			-----------------------

			eq previous_active_sensor : int = prev(Output.Active_Sensor, 1);
			
			eq previous_recommended_sensor : int = prev(Output.Recommended_Sensor, 1);

			eq previous_z_position : real = if (previous_active_sensor = 1) then 
												prev(InputFromSensor1.Position.Z, 0.0)
											else if (previous_active_sensor = 2) then
													prev(InputFromSensor2.Position.Z, 0.0)
												 else --(previous_active_sensor = 3)
												 	prev(InputFromSensor3.Position.Z, 0.0);
			
			eq Horizontal_Threshold : real = Unreliable_Sensor_Lib::HAL(previous_z_position);
			
			eq Vertical_Threshold : real = Unreliable_Sensor_Lib::VAL(previous_z_position);
							
			eq Sensor1_Reliable: bool, Sensor2_Reliable: bool, Sensor3_Reliable: bool = Unreliable_Sensor_Lib::Sensor_Status(InputFromSensor1, InputFromSensor2, InputFromSensor3, Horizontal_Threshold, Vertical_Threshold);
				
			guarantee "Sensor status to operator":
					(Output.Sensor1_Reliable = Sensor1_Reliable)
				and (Output.Sensor2_Reliable = Sensor2_Reliable)
				and (Output.Sensor3_Reliable = Sensor3_Reliable);			
			
			--Should we instead pick one of the three on some other criteria?
			guarantee "Recommended sensor is NIL if and only if all sensors are unreliable":
					Output.Recommended_Sensor = NIL <=> (not Sensor1_Reliable and not Sensor2_Reliable and not Sensor3_Reliable);
			
			guarantee "The recommended sensor is a reliable sensor, unless it is NIL":
					not (Output.Recommended_Sensor = NIL) =>
						(
							   (Output.Recommended_Sensor = 1 and Sensor1_Reliable)
							or (Output.Recommended_Sensor = 2 and Sensor2_Reliable)
							or (Output.Recommended_Sensor = 3 and Sensor3_Reliable)
						);
						
			guarantee "The recommended sensor is the active sensor unless the active sensor has become unreliable":			
					(		(previous_active_sensor = 1 and Output.Sensor1_Reliable)
						or 	(previous_active_sensor = 2 and Output.Sensor2_Reliable)
						or 	(previous_active_sensor = 3 and Output.Sensor3_Reliable)
					)
						=> (Output.Recommended_Sensor = previous_active_sensor);
 
			guarantee "The active sensor should stay the same unless the operator agrees that it is unreliable 
						and there is another reliable sensor available.":
				Output.Active_Sensor = 	
					if (previous_recommended_sensor = NIL)
						then previous_active_sensor
					else if ((previous_active_sensor = 1 and InputFromHuman.Sensor1_Unreliable_Response = enum(Response, Agree))
							  or (previous_active_sensor = 2 and InputFromHuman.Sensor2_Unreliable_Response = enum(Response, Agree))
							  or (previous_active_sensor = 3 and InputFromHuman.Sensor3_Unreliable_Response = enum(Response, Agree)))
						then previous_recommended_sensor
					else previous_active_sensor;
			
--			guarantee "The active sensor should stay the same unless the operator agrees that it is unreliable 
--						and there is another reliable sensor available.":
--				Output.Active_Sensor = 	
--					if (previous_recommended_sensor = NIL) 
--						then previous_active_sensor
--					else if (previous_active_sensor = 1 and InputFromHuman.Sensor1_Unreliable_Response = enum(Response, Agree)) 
--							then previous_recommended_sensor
--						 else if (previous_active_sensor = 2 and InputFromHuman.Sensor2_Unreliable_Response = enum(Response, Agree)) 
--						 		then previous_recommended_sensor
--							  else if (previous_active_sensor = 3 and InputFromHuman.Sensor3_Unreliable_Response = enum(Response, Agree)) 
--							  			then previous_recommended_sensor
--								   else	previous_active_sensor;

			-----------------------
			--FLIGHT PHASE STATE MACHINE
			-----------------------

			-------------------------------------------------------------
			--State machine support macros
									
			eq previous_phase : Phase_Type = prev(Output.Phase, enum(Phase_Type, On_Ground));

			eq some_transition: bool = T_Ground_to_Flight
										or T_Flight_to_Landing
										or T_Landing_to_Ground
										or T_Landing_to_Flight
										or T_Flight_to_Ground;
			-------------------------------------------------------------
			--State transition macros
			
			eq T_Ground_to_Flight: bool = 
				false -> ((previous_phase = enum(Phase_Type, On_Ground)) and not InputFromWOWSensor);
				
			eq T_Flight_to_Landing: bool =
				(previous_phase = enum(Phase_Type, In_Flight)) and InputFromHuman.Initiate_Landing;
			
			--This is not desirable. The pilot should initiate all landings before they occur, but it does seem to be a possible transition.	
			eq T_Flight_to_Ground: bool =
				(previous_phase = enum(Phase_Type, In_Flight)) and InputFromWOWSensor;
				
			eq T_Landing_to_Flight: bool =
				(previous_phase = enum(Phase_Type, Landing)) and InputFromHuman.Abort_Landing;
			
			eq T_Landing_to_Ground: bool =
				(previous_phase = enum(Phase_Type, Landing)) and InputFromWOWSensor;
				
			-------------------------------------------------------------	
			--State machine guarantees	
			
			--This guarantee specifies the initial state.
       		guarantee "Initial_State": (Output.Phase = enum(Phase_Type, On_Ground)) -> true;
        
	        --This guarantee captures all the "self loops" in shorthand form. 
	        -- It is important to state what happens when no transition condition is satisfied.
	        -- Otherwise the model checker will allow "spontaneous" transitions.
	        guarantee "Self loops": not some_transition => (Output.Phase = previous_phase);
        
        	-- Now we write one guarantee for each transition.
         
	        guarantee "T_Ground_to_Flight_effect" : 	T_Ground_to_Flight 	=> (Output.Phase = enum(Phase_Type, In_Flight));
	     
	     	guarantee "T_Flight_to_Landing_effect" : 	T_Flight_to_Landing => (Output.Phase = enum(Phase_Type, Landing));  
	     	
	     	guarantee "T_Flight_to_Ground_effect" : 	T_Flight_to_Ground	=> (Output.Phase = enum(Phase_Type, On_Ground));
	     	
	     	guarantee "T_Landing_to_Flight_effect" :	T_Landing_to_Flight => (Output.Phase = enum(Phase_Type, In_Flight));
	     	
	     	guarantee "T_Landing_to_Ground_effect" : 	T_Landing_to_Ground => (Output.Phase = enum(Phase_Type, On_Ground));
	     	
	     	-----------------------
			--ABORTED LANDING SCENARIO
			-----------------------
			
			guarantee "Landing options should be distinct":
					not (Output.Landing_Options.Option1 = Output.Landing_Options.Option2)
				and not (Output.Landing_Options.Option1 = Output.Landing_Options.Option3)		 								
				and not (Output.Landing_Options.Option2 = Output.Landing_Options.Option3);
				
			guarantee "Present landing options if and only if the landing is aborted":
				T_Landing_to_Flight = Output.Landing_Options_Ready;
				
			guarantee "Destination changes if and only if the pilot selects a landing option":
				true -> (Output.Destination = if pre(Output.Landing_Options_Ready) then 
												InputFromHuman.Landing_Option_Selection 
											  else 
											  	pre(Output.Destination)
				); 
			
			
		**};

	end IAS;
	
	---------------------------------------------------------
	-- S.F.R. 2022/05
	system implementation IAS.impl
		subcomponents
			sensor1ErrorData: data SensorErrorData.impl;
			sensor2ErrorData: data SensorErrorData.impl;
			sensor3ErrorData: data SensorErrorData.impl;
		annex agree {**
			-- QUESTION: is it possible to formulate properties about the likelihood of issuing an alert in range Level1 (resp.2) after an acceptance
			--			 or a rejection by the operator, without technical details about the learning algorithm?
			
			-- NOTE: should be a guarantee
			lemma l2 "If the sensor error is in Normal range, then no alert is issued":
			 	(sensor1ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Normal) => (not sensor1ErrorData.sensorErrorAlert)) and
			 	(sensor2ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Normal) => (not sensor2ErrorData.sensorErrorAlert)) and
			 	(sensor3ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Normal) => (not sensor3ErrorData.sensorErrorAlert));
			
			-- NOTE: should be a guarantee 	
			lemma l3 "If the sensor error is in Safety range, then an alert is issued":
			 	(sensor1ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Safety) => sensor1ErrorData.sensorErrorAlert) and
			 	(sensor2ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Safety) => sensor2ErrorData.sensorErrorAlert) and
			 	(sensor3ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Safety) => sensor3ErrorData.sensorErrorAlert);
			 
			 -- NOTE: observers for the generation of counter-example traces of interest
			 lemma l4 "Observer: if sensor 1 error is in Level1 range, then sometimes an alert is issued":
			 	(sensor1ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Level1) => (not sensor1ErrorData.sensorErrorAlert));
			 lemma l5 "Observer: if sensor 1 error is in Level1 range, then sometimes an alert is not issued":
			 	(sensor1ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Level1) => sensor1ErrorData.sensorErrorAlert);
			 lemma l6 "Observer: if sensor 1 error is in Level2 range, then sometimes an alert is issued":
			 	(sensor1ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Level2) => (not sensor1ErrorData.sensorErrorAlert));
			 lemma l7 "Observer: if sensor 1 error is in Level2 range, then sometimes an alert is not issued":
			 	(sensor1ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Level2) => sensor1ErrorData.sensorErrorAlert);
			 	
			 lemma l8 "Observer: if sensor 2 error is in Level1 range, then sometimes an alert is issued":
			 	(sensor2ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Level1) => (not sensor2ErrorData.sensorErrorAlert));
			 lemma l9 "Observer: if sensor 2 error is in Level1 range, then sometimes an alert is not issued":
			 	(sensor2ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Level1) => sensor2ErrorData.sensorErrorAlert);
			 lemma l10 "Observer: if sensor 2 error is in Level2 range, then sometimes an alert is issued":
			 	(sensor2ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Level2) => (not sensor2ErrorData.sensorErrorAlert));
			 lemma l11 "Observer: if sensor 2 error is in Level2 range, then sometimes an alert is not issued":
			 	(sensor2ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Level2) => sensor2ErrorData.sensorErrorAlert);
			 	
			 lemma l12 "Observer: if sensor 3 error is in Level1 range, then sometimes an alert is issued":
			 	(sensor3ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Level1) => (not sensor3ErrorData.sensorErrorAlert));
			 lemma l13 "Observer: if sensor 3 error is in Level1 range, then sometimes an alert is not issued":
			 	(sensor3ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Level1) => sensor3ErrorData.sensorErrorAlert);
			 lemma l14 "Observer: if sensor 3 error is in Level2 range, then sometimes an alert is issued":
			 	(sensor3ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Level2) => (not sensor3ErrorData.sensorErrorAlert));
			 lemma l15 "Observer: if sensor 3 error is in Level2 range, then sometimes an alert is not issued":
			 	(sensor3ErrorData.sensorErrorRange = enum(Types_Constants::SensorErrorRange, Level2) => sensor3ErrorData.sensorErrorAlert);
			 
			 -- NOTE: should be a guarantee
			 -- NOTE: arbitrary delays between alert issuing and communication to be tested 
			 lemma l16 "If a sensor alert is issued, then it is communicated to the operator; 
			 			if a sensor alert is not issued, then no sensor alert is communicated to the operator":
			 	(sensor1ErrorData.sensorErrorAlert <=> sensor1AlertToHuman.sensorErrorAlert) and
			 	(sensor2ErrorData.sensorErrorAlert <=> sensor2AlertToHuman.sensorErrorAlert) and
			 	(sensor3ErrorData.sensorErrorAlert <=> sensor3AlertToHuman.sensorErrorAlert);
			 	
 			-- NOTE: should be a guarantee
 			-- NOTE: equality between floats
			 lemma l17 "The computed sensor error is communicated to the operator":
				 	sensor1AlertToHuman.sensorError = sensor1ErrorData.sensorError and
				 	sensor2AlertToHuman.sensorError = sensor2ErrorData.sensorError and
				 	sensor3AlertToHuman.sensorError = sensor3ErrorData.sensorError;
		**};
	---------------------------------------------------------
	end IAS.impl;
	
	
	-------------------------------------
	-- Sensors
	-------------------------------------
		
	system Sensor1
		features
			Output : out data port Sensor_Data.impl;
	end Sensor1;
	
	system Sensor2
		features
			Output : out data port Sensor_Data.impl;
	end Sensor2;
	
	system Sensor3
		features
			Output : out data port Sensor_Data.impl;
	end Sensor3;
	
	system WOW_Sensor
		features
			Output : out data port Base_Types::Boolean;
	end WOW_Sensor;
	
	-------------------------------------
	-- Human-Machine Team
	-------------------------------------
	
	system Top
		annex agree {**
			guarantee "Placeholder gaurantee to get AGREE to run": true;
		**};
	end Top;

	system implementation Top.impl
	subcomponents
		Human: system Human;
		IAS: system IAS.impl; -- S.F.R. 2022/05 changed from IAS to IAS.impl
		Sensor1: system Sensor1;
		Sensor2: system Sensor2;
		Sensor3: system Sensor3;
		WOW_Sensor: system WOW_Sensor;
	connections
		Top_impl_new_connection: feature IAS.Output -> Human.InputFromIAS;
		Top_impl_new_connection2: feature Sensor1.Output -> IAS.InputFromSensor1;
		Top_impl_new_connection3: feature Sensor2.Output -> IAS.InputFromSensor2;
		Top_impl_new_connection4: feature Sensor3.Output -> IAS.InputFromSensor3;
		Top_impl_new_connection5: feature Human.Output -> IAS.InputFromHuman;
		Top_impl_new_connection6: feature Sensor1.Output -> Human.InputFromSensor1;
		Top_impl_new_connection7: feature Sensor2.Output -> Human.InputFromSensor2;
		Top_impl_new_connection8: feature Sensor3.Output -> Human.InputFromSensor3;
		Top_impl_new_connection9: feature WOW_Sensor.Output -> IAS.InputFromWOWSensor;
		Top_impl_new_connection10: feature WOW_Sensor.Output -> Human.InputFromWOWSensor;
		---------------------------------------------------------
		-- S.F.R. 2022/05
		-- NOTE: arbitrary delays in communication from the system to the human to be tested
		sensor1AlertResponseConnection: feature Human.sensor1AlertResponseToIAS -> IAS.sensor1AlertResponseFromHuman;	
		sensor2AlertResponseConnection: feature Human.sensor2AlertResponseToIAS -> IAS.sensor2AlertResponseFromHuman;
		sensor3AlertResponseConnection: feature Human.sensor3AlertResponseToIAS -> IAS.sensor3AlertResponseFromHuman;
		-- NOTE: arbitrary delays in communication from the human to the system to be tested
		sensor1AlertConnection: feature IAS.sensor1AlertToHuman -> Human.sensor1AlertFromIAS;
		sensor2AlertConnection: feature IAS.sensor2AlertToHuman -> Human.sensor2AlertFromIAS;
		sensor3AlertConnection: feature IAS.sensor3AlertToHuman -> Human.sensor3AlertFromIAS;
		---------------------------------------------------------
		
	annex agree {**
			---------------------------------------------------------
			-- S.F.R. 2022/05	
			
			lemma l18 "Observer: alerts from all sensors are received by the operator at the same step":
				not( Human.sensor1AlertFromIAS.sensorErrorAlert and  
				     Human.sensor2AlertFromIAS.sensorErrorAlert and 
				     Human.sensor3AlertFromIAS.sensorErrorAlert );
			
			lemma l19 "Observer: a sensor 1 error alert is communicated by the system to the operator and 
					             an acceptance response is received back at the next step":
				not( prev(IAS.sensor1AlertToHuman.sensorErrorAlert, false) and
				     prev(Human.sensor1AlertFromIAS.sensorErrorAlert, false) and  
				     Human.sensor1AlertResponseToIAS = enum(Types_Constants::SensorAlertResponse, Accept) and
				     IAS.sensor1AlertResponseFromHuman = enum(Types_Constants::SensorAlertResponse, Accept) );
			
			lemma l20 "Observer: a sensor 2 error alert is received by the operator, while sensor 2 is considered reliable":
				not( Human.sensor2AlertFromIAS.sensorErrorAlert and
					 Human.Output.Sensor1_Unreliable_Response = enum(Response, Agree) );
			 
			---------------------------------------------------------	

			
			--------------------------------------------
			-- EQ (STATE VARIABLES)
			--------------------------------------------
			eq previous_active_sensor : int = prev(IAS.Output.Active_Sensor, 1);
			eq previous_recommended_sensor : int = prev(IAS.Output.Recommended_Sensor, 1);
			eq reliable_sensor_available : bool = IAS.Output.Sensor1_Reliable or IAS.Output.Sensor2_Reliable or IAS.Output.Sensor3_Reliable;
			--------------------------------------------
			-- OBSERVERS (We want these to be invalid.)
			--------------------------------------------
			lemma "Observer: Operator agrees that Sensor 1 is unreliable":
													not (Human.Output.Sensor1_Unreliable_Response = enum(Response, Agree));
			lemma "Observer: IAS flags Sensor 1 unreliable":
													IAS.Output.Sensor1_Reliable;
			lemma "Observer: All sensors reliable":
													not (	IAS.Output.Sensor1_Reliable
														and IAS.Output.Sensor2_Reliable
														and IAS.Output.Sensor3_Reliable);
			lemma "Observer: All sensors unreliable":
														IAS.Output.Sensor1_Reliable
													or 	IAS.Output.Sensor2_Reliable
													or 	IAS.Output.Sensor3_Reliable;
			lemma "Observer: The active sensor changes":
													IAS.Output.Active_Sensor = prev(IAS.Output.Active_Sensor,1);
													
			--Check that all states are reachable
			lemma "Observer: On_Ground reachable" : not (IAS.Output.Phase = enum(Phase_type, On_Ground));
			lemma "Observer: In_Flight reachable" : not (IAS.Output.Phase = enum(Phase_type, In_Flight));
			lemma "Observer: Landing reachable" : not (IAS.Output.Phase = enum(Phase_type, Landing));
			
			--Check that all state transitions are reachable
			lemma "Observer: T_Ground_to_Flight is reachable" : not IAS.T_Ground_to_Flight;
			lemma "Observer: T_Flight_to_Landing is reachable" : not IAS.T_Flight_to_Landing;
			lemma "Observer: T_Landing_to_Ground is reachable" : not IAS.T_Landing_to_Ground;
			lemma "Observer: T_Landing_to_Flight is reachable" : not IAS.T_Landing_to_Flight;
			lemma "Observer: T_Flight_to_Ground is reachable" : not IAS.T_Flight_to_Ground;
			
			lemma "Observer: Destination changes" : true -> (IAS.Output.Destination = pre(IAS.Output.Destination)); 
			
			------------------------------------------------------------------------------
			-- LEMMAS (These should be true based on the guarantees of the subcomponents.)
			------------------------------------------------------------------------------
			lemma "Operator responds to unreliable sensor alerts": 
					(prev(not IAS.Output.Sensor1_Reliable, false) <=> ((Human.Output.Sensor1_Unreliable_Response = enum(Response, Agree)) or (Human.Output.Sensor1_Unreliable_Response = enum(Response, Disagree))))
				and (prev(not IAS.Output.Sensor2_Reliable, false) <=> ((Human.Output.Sensor2_Unreliable_Response = enum(Response, Agree)) or (Human.Output.Sensor2_Unreliable_Response = enum(Response, Disagree))))
				and (prev(not IAS.Output.Sensor3_Reliable, false) <=> ((Human.Output.Sensor3_Unreliable_Response = enum(Response, Agree)) or (Human.Output.Sensor3_Unreliable_Response = enum(Response, Disagree))));
			
			lemma "We can't have just Sensor 1 reliable":
					not (	 IAS.Output.Sensor1_Reliable and not IAS.Output.Sensor2_Reliable and not IAS.Output.Sensor3_Reliable);
			
			lemma "We can't have just Sensor 2 reliable":
					not (not IAS.Output.Sensor1_Reliable and 	 IAS.Output.Sensor2_Reliable and not IAS.Output.Sensor3_Reliable);
			
			lemma "We can't have just Sensor 3 reliable":
					not (not IAS.Output.Sensor1_Reliable and not IAS.Output.Sensor2_Reliable and 	 IAS.Output.Sensor3_Reliable);
			
			lemma "Unless the active sensor becomes unreliable, 
					the recommended sensor is the current active sensor":
					(		(previous_active_sensor = 1 and IAS.Output.Sensor1_Reliable)
						or 	(previous_active_sensor = 2 and IAS.Output.Sensor2_Reliable)
						or 	(previous_active_sensor = 3 and IAS.Output.Sensor3_Reliable))
					=> (IAS.Output.Recommended_Sensor = previous_active_sensor);
			
			lemma "If the operator agrees that the active sensor is unreliable, 
					the new active sensor is the previously recommended sensor, 
					unless the previously recommended sensor was NIL":
					previous_recommended_sensor != NIL =>
						(	((previous_active_sensor = 1 and Human.Output.Sensor1_Unreliable_Response = enum(Response, Agree)) => 
							IAS.Output.Active_Sensor = previous_recommended_sensor
							)
						and ((previous_active_sensor = 2 and Human.Output.Sensor2_Unreliable_Response = enum(Response, Agree)) => 
							IAS.Output.Active_Sensor = previous_recommended_sensor
							)
						and ((previous_active_sensor = 3 and Human.Output.Sensor3_Unreliable_Response = enum(Response, Agree)) => 
							IAS.Output.Active_Sensor = previous_recommended_sensor
							)
						);
			lemma "If the operator disagrees that the active sensor is unreliable, then the active sensor should not change.":
					(	(previous_active_sensor = 1 and Human.Output.Sensor1_Unreliable_Response = enum(Response, Disagree))
					or  (previous_active_sensor = 2 and Human.Output.Sensor2_Unreliable_Response = enum(Response, Disagree))
					or 	(previous_active_sensor = 3 and Human.Output.Sensor3_Unreliable_Response = enum(Response, Disagree))
					) 
					=>
					IAS.Output.Active_Sensor = previous_active_sensor;
			
			lemma "If an unreliable sensor is the active sensor, it must be the case that either 
					the pilot disagreed with the IAS assessment 
					or the sensor just became unreliable on this timestep 
					or there was no reliable sensor available on the previous timestep":
						((IAS.Output.Active_Sensor = 1) and not IAS.Output.Sensor1_Reliable) 
							=>  (	(Human.Output.Sensor1_Unreliable_Response = enum(Response, Disagree)) 
								or 	prev(IAS.Output.Sensor1_Reliable, true) 
								or not prev(reliable_sensor_available, true)
								)
					and ((IAS.Output.Active_Sensor = 2) and not IAS.Output.Sensor2_Reliable) 
							=>  (	(Human.Output.Sensor2_Unreliable_Response = enum(Response, Disagree)) 
								or 	prev(IAS.Output.Sensor2_Reliable, true) 
								or 	not prev(reliable_sensor_available, true)
								)
					and ((IAS.Output.Active_Sensor = 3) and not IAS.Output.Sensor3_Reliable) 
							=>  (	(Human.Output.Sensor3_Unreliable_Response = enum(Response, Disagree)) 
								or 	prev(IAS.Output.Sensor3_Reliable, true) 
								or not prev(reliable_sensor_available, true)
							);
			
			lemma "If Sensor 1 is both the active sensor and unreliable, it must be the case that either
				the pilot disagreed with the IAS assessment 
				or the sensor just became unreliable on this timestep 
				or there was no reliable sensor available on the previous timestep":
						((IAS.Output.Active_Sensor = 1) and not IAS.Output.Sensor1_Reliable) 
							=>  (	(Human.Output.Sensor1_Unreliable_Response = enum(Response, Disagree)) 
								or 	prev(IAS.Output.Sensor1_Reliable, true) 
								or not prev(reliable_sensor_available, true));
			
			lemma "Active sensor in range":
				IAS.Output.Active_Sensor >= 1 and IAS.Output.Active_Sensor <= 3;
			
			lemma "Recommended active sensor in range":
				IAS.Output.Recommended_Sensor >= 0 and IAS.Output.Recommended_Sensor <= 3;
														
			lemma "Only stated transitions are allowed." :
				IAS.some_transition or (IAS.Output.Phase = IAS.previous_phase);
			
			------------------------------------------------------------------------------
			-- INVALID LEMMAS (These are notably invalid.)
			------------------------------------------------------------------------------
			
			lemma "Invalid (because the operator may disagree): The active sensor is always a reliable sensor (on the previous timestep) when a reliable sensor is available":
				true -> (pre(reliable_sensor_available)
						=>
						(	(IAS.Output.Active_Sensor = 1 => pre(IAS.Output.Sensor1_Reliable))
						and (IAS.Output.Active_Sensor = 2 => pre(IAS.Output.Sensor2_Reliable))
						and (IAS.Output.Active_Sensor = 3 => pre(IAS.Output.Sensor3_Reliable))));
		**};
end Top.impl;
	
	
end Human_IAS_Team;
